# Jo娜贝尔 (Bye-JonaBell.c)

## 题目描述

现在有一场游戏，规则如下

JonaBell 们按照顺序排成一圈，从某一只 JonaBell 开始，顺时针编号为 1∼n。

从 11 号 JonaBell 开始，每只 JonaBell 按顺时针从 1 开始报数，EagleBear 会向报数到 k 的 JonaBell 发射水弹。

如果这时水枪还能发射出水弹，这只 JonaBell 就会因为被淋湿而失去尾巴并且和大家 say goodbye，否则 EagleBear 会在此时给水枪吸水，装填满水弹，且这次**不会发射**，JonaBell 们继续按顺序报数。

请注意：无论水枪是否射出水弹，JonaBell 们都会跳过当前被水枪锁定的 JonaBell，从她的顺序下一位开始依次从 1 报数。

可 EagleBear 领来的一些 JonaBell 们有不止一条尾巴。每只 JonaBell 都有 l 条尾巴，而每只 JonaBell 被淋湿一次就会失去一条尾巴。每只 JonaBell 只有在第 l 次淋湿、失去所有尾巴时才会和大家 say goodbye，在此之前该 JonaBell 一直在游戏中参与报数。

EagleBear 希望你使用 C 语言帮他算出哪只 JonaBell 是最后 say goodbye 的，直接宣布这只 JonaBell 的胜利。

### 输入格式
共一行，四个整数，依次为：

1. JonaBell 的数目 n ；
2. 会被水枪射击的 JonaBell 的报数 k ；
3. 水枪的最大装填数 b ；
4. 每只 JonaBell 的尾巴数目 l。

我们对数据做出以下保证：

对于 50% 的数据，保证 $b≥n$，$l=1$，其余同下；
对于 100% 的数据，保证 $1≤n≤1500$，$1≤k≤1500$，$2≤b≤2^{31}−1$，$1≤l≤9$

### 输出格式

共一行，一个整数，为不会和大家 say goodbye 的 JonaBell 的编号。

### 测试样例1

##### Input

------

```
6 5 6 1
```

##### Output

------

```
1
```

样例1解释：

6 只 JonaBell 围成一圈，报数到 5 的 JonaBell 会被水枪淋湿而失去一条尾巴，水枪的最大装填数是 6，每只 JonaBell 只有一条尾巴。

游戏中，依次和大家 say goodbye 的 JonaBell 编号是：5，4，6，2，3。

### 测试样例2

##### Input

------

```
6 5 3 1
```

##### Output

------

```
3
```

样例2解释：

6 只 JonaBell 围成一圈，报数到 5 的 JonaBell 会被水枪淋湿而失去一条尾巴，水枪的最大装填数是 3，每只 JonaBell 只有一条尾巴。

游戏中，依次和大家 say goodbye 的 JonaBell 编号是：5，4，6，1，2。

其中 ，6 号 goodbye 后、1 号 goodbye 前，EagleBear 需要重新装填一次水弹。



## Code

```c
#include <stdio.h>

int main() {
    int n, k, b, l;
    scanf("%d %d %d %d", &n, &k, &b, &l);

    // 创建并初始化JonaBell的尾巴数数组
    int tails[n];
    for (int i = 0; i < n; i++) {
        tails[i] = l;
    }

    // 初始化当前的水枪装填数、当前报数、当前JonaBell索引和游戏中的JonaBell数
    int bullets = b, count = 0, index = 0, inGame = n;

    // 循环直到只剩下一只JonaBell
    while (inGame > 1) {
        // 如果当前JonaBell还有尾巴，则报数
        if (tails[index] > 0) count++;
        
        // 如果报数达到k
        if (count == k) {
            // 如果水枪中还有子弹
            if (bullets > 0) {
                // 该JonaBell失去一条尾巴
                tails[index]--;
                // 如果JonaBell失去了所有尾巴，更新游戏中的JonaBell数
                if (tails[index] == 0) inGame--;
                // 水枪中的子弹减少
                bullets--;
            } else {
                // 如果水枪没有子弹了，则重新装填
                bullets = b;
            }
            // 重新开始报数
            count = 0;
        }

        // 移动到下一只JonaBell
        index = (index + 1) % n;
    }

    // 找到唯一剩下的JonaBell
    for (int i = 0; i < n; i++) {
        if (tails[i] > 0) {
            printf("%d\n", i + 1);
            break;
        }
    }

    return 0;
}
```

这个问题本质上是约瑟夫问题（Josephus problem）的一个变种。约瑟夫问题是一个著名的理论问题，通常是围绕着一群人站成圈，然后每数到某个数就会有一个人被排除出圈子，问题是最后剩下的是哪个人。在本题中，不仅仅是每数到 k 就会有一个 JonaBell 被排除，而且每个 JonaBell 可能需要被多次淋湿才会被最终排除，加之水枪需要重新装填。

这题的解题思路可以概括为以下几个步骤：

1. **初始化状态**：我们需要初始化一个数组来表示每个JonaBell的尾巴数量，还需要变量来跟踪当前的水枪装填状态、当前报数，以及在游戏中剩余的 JonaBell 数量。

2. **模拟报数**：模拟 JonaBell 们报数的过程。对于每个 JonaBell，如果它仍然在游戏中（尾巴数大于0），就进行报数。

3. **判断淋湿与否**：当报数达到 k 时，要判断水枪是否还有子弹。如果有，当前 JonaBell 失去一条尾巴，水枪的子弹数减少。如果没有，重新装填水枪。

4. **尾巴检查和循环继续**：每次 JonaBell 失去一条尾巴后，检查是否失去了所有的尾巴。如果一个 JonaBell 失去了最后一条尾巴，它就被从游戏中排除，游戏中的 JonaBell 数量减少。然后报数重置，并继续循环。

5. **结束条件**：当只剩下一个 JonaBell 时，游戏结束。循环会持续到剩下最后一个 JonaBell。

6. **输出胜利者**：最后剩下的 JonaBell 即为游戏的胜利者，输出这个 JonaBell 的编号。

代码的关键部分就是在模拟报数的循环中正确处理各种情况，确保当水枪需要装填时，当前的 JonaBell 不会被淋湿，也不会被排除。只有当水枪里有子弹的时候，被报数到 k 的 JonaBell 才会失去尾巴。此外，如果 JonaBell 失去最后一条尾巴，则会从游戏中排除，也就是它们会和大家 say goodbye。最后检查剩余的尾巴数来确定最后的胜利者。

这种模拟过程是非常直接的算法实现方式，虽然它在 n、k 和 l 比较大的情况下可能效率不是最优的，但它足够直观，易于理解和实现。对于本题的数据范围（$ 1≤n≤1500 $），这种方法的时间复杂度是可接受的。

![image-20231104114624917](C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231104114624917.png)

#### “能否优化这段代码呢”

GPT-4：

> 为了优化代码，我们可以尝试减少重复的计算和不必要的循环。由于每个 JonaBell 可以被淋湿多次，我们可以尝试预先计算每个 JonaBell 被淋湿的次数，以及每次水枪需要重新装填的时间点。
>
> 这种优化主要是在减少模拟中循环的次数。但由于游戏的规则较为复杂，需要同时跟踪多个变量（水枪的装填次数、JonaBell 的报数等），直接计算出最后一只 JonaBell 的编号而不进行模拟可能会很困难。
>
> 考虑到这一点，代码的优化可能并不会带来算法复杂度的显著降低，而是通过减少某些操作来尝试加快运行速度。例如，我们可以用一个计数器来跟踪当前水枪中还剩下多少发子弹，以及当前报数，这样可以避免对水枪装填次数的重复计算。
>
> 不过，正如我前面提到的，我们可以采取的优化策略在此数据规模（1≤n≤1500）下提升有限，因为基本的模拟策略已经足够应对此范围。此外，对于此类问题，模拟通常是最直接和最容易理解的方法，也是在面试或竞赛中最常采取的方法，因为它易于编写且不容易出错。
>
> 然而，如果你需要处理更大规模的数据，那么考虑数学解或者更高效的数据结构（比如树状数组或者线段树）来跟踪 JonaBell 的状态就变得必要了。这些方法可以提供更快的更新和查询操作，从而减少总体的运算时间。但这也会增加实现的复杂性，对于这个问题可能是过度优化。