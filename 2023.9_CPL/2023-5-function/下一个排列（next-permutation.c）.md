# 下一个排列（next-permutation.c）

## 题目描述

给出一个长度为 n 的排列 $p_1,p_2,⋯,p_n$，请按照题目注解中给出的方法，求出这个排列的下一个排列。

一个长度为 n 的序列能被称为排列当且仅当 1,2,⋯,n每个数都恰好出现一次，比如 1, 2, 3， 3, 1, 2 都是长度为 3 的排列，而 2, 2, 1 则不能被称为一个排列。

本题中的下一个排列是字典序意义上的（[什么是字典序？](https://zh.wikipedia.org/zh-hans/字典序)），长度为 n 的排列一共有 n! 个，将排列中的所有数连成一个字符串，并将这 n! 个串排序，我们可以得到一个长度为 n! 的升序字符串序列，本题要求你输出给出的排列的下一个排列。

### 输入格式

输入一共包括两行。

第一行为一个整数 $n(n≤2000)$，表示排列的长度。

第二行为 n 个整数，$p_1,p_2,⋯,p_n$，表示给出的排列。

保证给出的排列都能找出下一个排列，形式化地说，给出的排列 $p_1,p_2,⋯,p_n$   不满足 $∀1≤i≤n,p_i=n−i+1$。

### 输出格式

输出包括一行 n 个整数，表示给出的排列的下一个排列。

### 测试样例

##### Input

------

```
5
3 1 2 4 5
```

##### Output

------

```
3 1 2 5 4
```

##### Input

------

```
3
1 2 3
```

##### Output

------

```
1 3 2
```

##### Input

------

```
9
6 3 1 5 8 9 4 2 7
```

##### Output

------

```
6 3 1 5 8 9 4 7 2
```

##### Input

------

```
9
6 3 1 5 4 9 8 7 2
```

##### Output

------

```
6 3 1 5 7 2 4 8 9
```

### 题目注解
求下一个排列的方法
找出给出的排列的最长连续递降后缀，其长度记为 $m(m<n)$。
找到最长递降后缀的之前的那个数，记为 $p_k$，在最长递降后缀中找到比 $p_k$ 大的数中最小的那个，交换这两个数。
将交换后的序列的后 m 个数翻转。

举个例子，假如给出的排列为`1 3 5 4 2`，最长递降后缀为`5 4 2`，最长递降后缀不为`3 5 4 2`，因为`3 5`不递降；最长递降后缀不为`4 2`，因为其不满足“最长”的性质。最长递降后缀之前的那个数为`3`，找到最长递降后缀中比`3`大的那个数中最小的那个：`4`，交换后为`1 4 5 3 2`，将这个序列中后3位翻转后得到`1 4 2 3 5`，即为最后答案。

**后缀：将原序列从头开始删去一段连续若干元素（可以为 0 个）之后剩下的部分，比如序列 `1 3 5 4 2` 的所有后缀包括 `1 3 5 4 2` 、 `3 5 4 2` 、 `5 4 2` 、 `4 2` 、 `2` 。**



## 思路

这个题目要求找到给定排列的下一个字典序排列。解决这个问题的策略可以分为以下几个步骤：

1. **找到最长递减后缀：**
    - 从数组的尾部开始，向前找，直到找到一个数，这个数比其后面的数小。例如，在数组 `[1, 3, 5, 4, 2]` 中，从尾部开始找，`[5, 4, 2]` 是递减的。

2. **找到要交换的元素：**
    - 之后我们找到在这个递减后缀中比找到的那个数（步骤1中找到）大的最小数，并交换它们。在前述例子中，`3` 是我们找到的数，而在递减后缀 `[5, 4, 2]` 中，比 `3` 大的最小数是 `4`，所以交换 `3` 和 `4`。

3. **翻转递减后缀：**
    - 在交换完元素之后，我们得到的数组是 `[1, 4, 5, 3, 2]`。此时，我们需要翻转之前找到的递减后缀，使它变为递增序列。翻转后缀 `[5, 3, 2]` 后，数组变成 `[1, 4, 2, 3, 5]`。

以下是按照这个策略进行步骤说明的伪代码：

```plaintext
1. 从后向前寻找第一个不满足 arr[i] > arr[i+1] 的索引 i
2. 如果找到了这样的索引 i：
    a. 再次从后向前寻找第一个满足 arr[j] > arr[i] 的索引 j
    b. 交换 arr[i] 和 arr[j]
3. 翻转索引 i+1 到数组末尾的部分
```

通过这种方法，我们可以保证找到的是刚好比当前排列大的下一个排列，符合字典序要求。