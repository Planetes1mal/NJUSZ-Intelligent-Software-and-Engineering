# 0-1 比特翻转 (flip.c)

## 题目描述

考虑一个长度为  n 的 01 比特序列（$n \leq 2000$），各比特编号为 $1，2，3，…，n$

序列初始为全 0，现对其进行如下 n 次（$n = 1，2，3，…，i，…，n$）操作：

第 i 次操作会翻转编号为 i 的倍数的比特： 1 变成 0，0 变成 1。

第 n 次操作结束后，请输出最后为 1 的比特的编号。

### 输入格式

输入为一行一个整数 n ，表示序列的长度。

### 输出格式

输出一共包含一行，可能包含多个整数。

从小到大输出所有最后为 1 的比特的编号。

### 测试样例

##### Input

------

```
5
```

##### Output

------

```
1 4
```

### 题目注解

提示：

仔细看看输出，你能发现什么规律吗？



## 题解

### 解题方法 1 - 完全平方规律

在这个问题中，我们有一个初始值全为0的比特序列，然后进行一系列操作，每一次操作都会翻转某些比特（1变成0，0变成1）。每次操作的比特编号是操作次数的倍数。

现在，让我们来看看为什么完全平方数的编号最终会变成1。考虑一个完全平方数x，它有一些因数，这些因数可以分成成对出现的。例如，如果x是16，它的因数为1, 2, 4, 8, 16，可以分成如下对：(1, 16) 和 (2, 8)。每对中的两个因数相乘等于完全平方数x。对于其他非完全平方数，它们的因数总是无法成对出现的。

现在，当我们执行操作时，第i次操作会翻转所有编号为i的倍数的比特。对于完全平方数x，它的因数会导致它的比特编号在操作过程中被多次翻转。具体地，每个因数都会导致该编号的比特在操作过程中翻转两次（一次从0变成1，另一次从1变成0）。这是因为因数成对出现，一次翻转是由因数的一个元素触发，另一次翻转是由另一个元素触发。

对于非完全平方数，它们的因数总是无法成对出现的，因此它们的编号在操作中只会被翻转偶数次。这意味着它们最终会停留在0。

所以，完全平方数的编号最终会变成1，而非完全平方数的编号最终会保持为0。

#### 复杂度

- 时间复杂度：添加时间复杂度, 示例： $O(\sqrt{n})$

- 空间复杂度：添加空间复杂度, 示例： $O(1)$

#### Code

```c

```

### 解题方法 2 - 常规解法

首先读取序列的长度n，然后使用两个数组bits和result来记录每个比特的状态以及最后为1的比特的编号。接着，使用两个嵌套的循环，外循环控制操作次数i，内循环根据i的倍数来翻转比特。最后，将最后为1的比特的编号存储在result数组中，并输出。

#### 复杂度

- 时间复杂度：添加时间复杂度, 示例： $O(\sqrt{n})$

- 空间复杂度：添加空间复杂度, 示例： $O(1)$

#### Code

```c

```

### 
