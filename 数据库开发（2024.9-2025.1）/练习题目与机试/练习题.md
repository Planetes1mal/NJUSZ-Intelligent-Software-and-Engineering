# 公司职员

设有一个公司内部信息管理数据库，表结构如下：

有`employees`表，

```
+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
|  eno         | int     |
|  ename       | varchar |
|  salary      | int     |
|  dno         | int     |
+--------------+---------+
eno为该表主键。
该表包含员工的工号，姓名，工资，部门编号等信息
```

有`projects`表，

```
+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
|  pno         | int     |
|  pname       | varchar |
|  city        | varchar |
|  dno         | int     |
+--------------+---------+
pno为该表主键。
该表包含项目的项目编号，项目名称，所在城市，负责部门编号等信息。
```

有`works`表，

```
+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
|  eno         | int     |
|  pno         | int     |
|  hours       | int     |
+--------------+---------+
(eno,pno)为该表主键。
该表包含员工的工号，参与的项目，在项目上工作的时间等信息
```

有`relations`表，

```
+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
|  eno         | int     |
|  rname       | varchar |
|  sex         | varchar |
+--------------+---------+
(eno,name)为该表主键。
该表包含员工的工号，家属姓名，家属性别等信息
```

1. 编写一个sql语句，查询累计工作时间超过1000的职工，结果返回职工工号eno。      

```sql
SELECT eno
FROM employees
WHERE eno NOT IN (
    SELECT eno
    FROM relations
);
```

2.  编写一个sql语句，查询没有登记家属的职工，结果返回职工工号eno。

```sql
SELECT eno
FROM employees
WHERE eno NOT IN (
    SELECT eno
    FROM relations
);
```

3. 编写一个sql语句，查询所有职工都参与的项目，结果返回项目编号pno。 

```sql
SELECT pno
FROM works
GROUP BY pno
HAVING COUNT(DISTINCT eno) = (SELECT COUNT(*) FROM employees);
```

4. 编写一个sql语句，查询每一个部门中薪水最高的职工，结果返回部门编号dno，薪水最高的职工工号eno和薪水salary，以dno升序排列。 

```sql
SELECT dno, eno, salary
FROM employees
WHERE (dno, salary) IN (
    SELECT dno, MAX(salary)
    FROM employees
    GROUP BY dno
)
ORDER BY dno ASC;
```



# 船只租赁

设有一个船员租赁船只系统，表结构如下：

有`sailors`表，

```
+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
|  sid         | int     |
|  sname       | varchar |
|  rating      | int     |
|  age         | int     |
+--------------+---------+
sid为该表主键。
该表包含船员的编号，姓名，等级和年龄
```

有`boats`表，

```
+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
|  bid         | int     |
|  bname       | varchar |
|  color       | varchar |
+--------------+---------+
bid为该表主键。
该表包含船只编号，船只名称和船只颜色
```

有`reserves`表，

```
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
|  sid          | int     |
|  bid          | int     |
|  reserve_date | date    |
+---------------+---------+
(sid,bid)为该表主键。
该表包含船员编号，船员预定的船只编号，船员预定船只的日期
```

1. 编写一个sql语句，找出年龄在35以上的并且在2020-09-01至2020-09-30期间没有预定红色（RED）船只的水手，结果返回水手姓名sname。 

```sql
SELECT sname
FROM sailors s
WHERE s.age > 35
AND s.sid NOT IN (
    SELECT r.sid
    FROM reserves r
    JOIN boats b ON r.bid = b.bid
    WHERE b.color = 'RED'
    AND r.reserve_date BETWEEN '2020-09-01' AND '2020-09-30'
);
```

2. 编写一个sql语句，找出预定了所有船的水手，结果返回水手姓名sname。 

```
SELECT s.sname
FROM sailors s
JOIN reserves r ON s.sid = r.sid
GROUP BY s.sid, s.sname
HAVING COUNT(DISTINCT r.bid) = (SELECT COUNT(*) FROM boats);
```

3. 编写一个sql语句，找出2020-05-01至2020-05-31期间预定过绿色船（GREEN）的等级最高的水手，结果返回水手姓名sname。 

```
SELECT s.sname
FROM sailors s
JOIN reserves r ON s.sid = r.sid
JOIN boats b ON r.bid = b.bid
WHERE b.color = 'GREEN'
AND r.reserve_date BETWEEN '2020-05-01' AND '2020-05-31'
ORDER BY s.rating DESC
LIMIT 1;
```

4. 编写一个sql语句，找出年龄在35岁以上，并且在2020-08-01至2020-08-31期间同时预定了红色船（RED）和绿色船（GREEN）的水手，结果返回水手姓名sname，按sname降序排列

```
SELECT s.sname
FROM sailors s
JOIN reserves r ON s.sid = r.sid
JOIN boats b ON r.bid = b.bid
WHERE s.age > 35
AND r.reserve_date BETWEEN '2020-08-01' AND '2020-08-31'
AND b.color IN ('RED', 'GREEN')
GROUP BY s.sid, s.sname
HAVING COUNT(DISTINCT b.color) = 2;
```



# 顾客与商品

对于顾客购买产品，系统中有以下表结构：

表: `customers`

```
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| customer_id   | int     |
| name          | varchar |
+---------------+---------+
customer_id 是该表主键。
该表包含消费者的id和姓名.
```

表: `orders`

```
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| order_id      | int     |
| order_date    | date    |
| customer_id   | int     |
| product_id    | int     |
+---------------+---------+
order_id 是该表主键。
该表包含消费者产生的订单编号，订单日期，顾客id和商品id。
不会有商品被相同的用户在一天内下单超过一次。
```

表: `products`

```
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| product_id    | int     |
| product_name  | varchar |
| price         | int     |
+---------------+---------+
product_id 是该表主键。
该表包含所有商品id，商品名称和商品价格.
```

1. 编写一个sql语句，查询每件商品都购买过的用户，结果返回用户编号customer_id。

```
SELECT c.customer_id
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id
HAVING COUNT(DISTINCT o.product_id) = (SELECT COUNT(*) FROM products);
```

2. 编写一个sql语句，找出2020-08-01至2020-08-31期间订单数量最多的客户，数量相同时选择customer_id较小的用户，结果返回用户编号customer_id和购买数量order_num

```
SELECT customer_id, COUNT(order_id) AS order_num
FROM orders
WHERE order_date BETWEEN '2020-08-01' AND '2020-08-31'
GROUP BY customer_id
ORDER BY order_num DESC, customer_id ASC
LIMIT 1;
```

3. 编写一个sql语句，找出每件商品的最新订单(可能有多个)，结果返回商品名称product_name，订单号order_id和订单日期order_date，以product_name、order_id升序排列

```
SELECT p.product_name, o.order_id, o.order_date
FROM orders o
JOIN products p ON o.product_id = p.product_id
WHERE o.order_date = (
    SELECT MAX(order_date)
    FROM orders o2
    WHERE o2.product_id = o.product_id
)
ORDER BY p.product_name ASC, o.order_id ASC;
```

4. 编写一个sql语句，找到每个用户最近三笔订单。若用户订单少于3笔，则返回该用户的全部订单，结果返回用户名customer_name，订单编号order_id和订单日期order_date，以custromer_name、order_id升序排列

```
SELECT c.name, o.order_id, o.order_date
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
WHERE (
    SELECT COUNT(*)
    FROM orders o2
    WHERE o2.customer_id = o.customer_id
    AND o2.order_date >= o.order_date
) <= 3
GROUP BY c.customer_id, c.name, o.order_id, o.order_date
HAVING COUNT(*) <= 3
ORDER BY c.name ASC, o.order_id ASC;
```



# 选手与比赛

在一场赛事中，选手经过分组后参加比赛，有以下表结构，
 `players `玩家表

```
+-------------+-------+
| Column Name | Type  |
+-------------+-------+
| player_id   | int   |
| group_id    | int   |
+-------------+-------+
player_id是此表的主键。
该表包含选手id以及所在的组别
```

`matches` 赛事表

```
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| match_id      | int     |
| first_player  | int     |
| second_player | int     | 
| first_score   | int     |
| second_score  | int     |
| group_id      | int     |
+---------------+---------+
match_id 是此表的主键。
该表包含一场比赛的比赛id，参与比赛的第一位选手和第二位选手，第一位选手的分数和第二位选手的分数以及两位选手所处的组别。
```

1. 编写一个sql语句，查询参加比赛场次最多的选手，若参与比赛场次相同，选择用户编号player_id较小的选手，结果返回用户编号player_id和参与的比赛数量match_num

```
SELECT player_id, COUNT(match_id) AS match_num
FROM (
    SELECT first_player AS player_id, match_id
    FROM matches
    UNION ALL
    SELECT second_player AS player_id, match_id
    FROM matches
) AS combined_players
GROUP BY player_id
ORDER BY match_num DESC, player_id ASC
LIMIT 1;
```

2. 编写一个sql语句，查询各组进行的比赛场次，结果返回组号group_id及各组的场次数match_num

```
SELECT group_id, COUNT(match_id) AS match_num
FROM matches
GROUP BY group_id;
```

3. 编写一个sql语句，查询分差最大的一场比赛，若分差相同，选择编号match_id较小的比赛，结果返回比赛编号match_id和分差sub（大于0）

```
SELECT match_id, ABS(first_score - second_score) AS sub
FROM matches
ORDER BY sub DESC, match_id ASC
LIMIT 1;
```

4. 编写一个sql语句，查找每组中的获胜者。每组的获胜者是在组内累积得分最高的选手。如果有得分相同的情况，则认为player_id 最小的选手获胜，结果返回组号group_id和选手编号player_id，以group_id升序排列

```
SELECT ps.group_id, ps.player_id
FROM (
    SELECT p.group_id, p.player_id,
        COALESCE(SUM(
            CASE
                WHEN m.first_player = p.player_id THEN m.first_score
                WHEN m.second_player = p.player_id THEN m.second_score
                ELSE 0
            END
        ), 0) AS total_score
    FROM players p
    LEFT JOIN matches m ON p.player_id = m.first_player OR p.player_id = m.second_player
    GROUP BY p.group_id, p.player_id
) AS ps
JOIN (
    SELECT group_id, MAX(total_score) AS max_score
    FROM (
        SELECT p.group_id, p.player_id,
            COALESCE(SUM(
                CASE
                    WHEN m.first_player = p.player_id THEN m.first_score
                    WHEN m.second_player = p.player_id THEN m.second_score
                    ELSE 0
                END
            ), 0) AS total_score
        FROM players p
        LEFT JOIN matches m ON p.player_id = m.first_player OR p.player_id = m.second_player
        GROUP BY p.group_id, p.player_id
    ) AS grouped_scores
    GROUP BY group_id
) AS max_scores ON ps.group_id = max_scores.group_id AND ps.total_score = max_scores.max_score
ORDER BY ps.group_id ASC,  ps.player_id ASC;
```



# 顾客与商品2

一位用户，既可以作为卖家也可以作为买家参与一场交易，以下为相关的表结构，

表: `users`

```
+----------------+---------+
| Column Name    | Type    |
+----------------+---------+ 
| user_id        | int     |
| join_date      | date    |
| favorite_brand | varchar |
+----------------+---------+
user_id 是该表的主键
表中包含一位某网站用户的个人id，注册时间和最喜欢的品牌。
```

表: `orders`

```
---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| order_id      | int     |
| order_date    | date    |
| item_id       | int     |
| buyer_id      | int     |
| seller_id     | int     |
+---------------+---------+
order_id 是该表的主键
该表包含订单的id，日期，商品id，买方id和卖方id
```

表: `items`

```
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| item_id       | int     |
| item_brand    | varchar |
+---------------+---------+
item_id 是该表的主键
该表包含商品id和商品品牌
```

编写一个sql查询，查找订单数量最多的一天以及当天的订单数量，订单数相同时选择日期最小的一天，结果返回日期order_date和订单数量num。          

```
SELECT order_date, COUNT(order_id) as num
FROM orders
GROUP BY order_date
ORDER BY num DESC, order_date ASC
LIMIT 1;
```

编写一个sql语句，查找买到过自己最喜欢的商品的用户，结果返回用户编号user_id

```
SELECT u.user_id
FROM users u
JOIN orders o ON u.user_id = o.buyer_id
JOIN items i ON o.item_id = i.item_id
WHERE u.favorite_brand = i.item_brand;
```

编写一个sql语句，查询每个用户的注册日期以及在2019年作为买家的订单总数，结果返回用户编号user_id，注册日期join_date和订单数量orders_in_2019，以user_id升序排列

```
SELECT u.user_id, u.join_date, COUNT(o.order_id) as orders_in_2019
FROM users u
LEFT JOIN orders o ON u.user_id = o.buyer_id AND YEAR(o.order_date) = 2019
GROUP BY u.user_id, u.join_date
ORDER BY u.user_id ASC;
```

编写一个sql语句，查询每一个用户按顺序卖出的第二件商品是否是他们最喜爱的品牌。结果返回卖家编号seller_id和是否是最喜爱品牌的情况if_fav_brand（取值为'yes'，'no'，售出小于2件时返回 ‘no’），以seller_id升序排列

```
SELECT 
    u.user_id AS seller_id,
    CASE 
        WHEN COUNT(o.order_id) < 2 THEN 'no'
        WHEN (
            SELECT i.item_brand
            FROM orders o2
            JOIN items i ON o2.item_id = i.item_id
            WHERE o2.seller_id = u.user_id
            ORDER BY o2.order_date
            LIMIT 1 OFFSET 1
        ) = u.favorite_brand THEN 'yes'
        ELSE 'no'
    END AS if_fav_brand
FROM users u
LEFT JOIN orders o ON u.user_id = o.seller_id
GROUP BY u.user_id, u.favorite_brand
ORDER BY seller_id ASC;
```



# 好友申请

在 Facebook 或者 Twitter 这样的社交应用中，人们经常会发好友申请也会收到其他人的好友申请。现在给如下两个表：

表: `friend_requests`

```
+----------------+---------+
| Column Name    | Type    |
+----------------+---------+ 
| sender_id      | int     |
| send_to_id     | int     |
| request_date   | date    |
+----------------+---------+
(sender_id,send_to_id,request_date) 是该表的主键
一个人可能会向另一个人发送多条申请
```

表: `accepted_requests`

```
+----------------+---------+
| Column Name    | Type    |
+----------------+---------+ 
| requester_id   | int     |
| accepter__id   | int     |
| accept_date    | date    |
+----------------+---------+
(request_id,accepter_id,accept_date) 是该表的主键
一个人可能会多次同意其他人的申请
```

编写一个sql语句，求出好友申请的总通过率accept_rate，用2位小数表示。通过率计算公式为接受好友申请的数目除以申请总数（申请和接收可能会有重复，此时均视作一次）

```
SELECT 
    ROUND(
        (SELECT COUNT(DISTINCT requester_id, accepter_id) FROM accepted_requests) * 1.0 / 
        (SELECT COUNT(DISTINCT sender_id, send_to_id) FROM friend_requests), 
        2
    ) AS accept_rate;
```

编写一个sql语句，查询发出过申请，但所有申请都未通过的用户，结果返回用户编号user_id。 

```
SELECT DISTINCT fr.sender_id AS user_id
FROM friend_requests fr
LEFT JOIN accepted_requests ar
ON fr.sender_id = ar.requester_id
WHERE ar.requester_id IS NULL;
```

编写一个sql语句，查询每个月的通过率，结果返回月份mon及通过率accept_rate（不包括通过率为0的月份），以mon升序排列

```
SELECT r.mon, IFNULL(a.total_accepted, 0) / r.total_requests AS accept_rate
FROM (
	SELECT month(request_date) AS mon, COUNT(DISTINCT sender_id, send_to_id) AS total_requests
	FROM friend_requests
	GROUP BY mon
) r
LEFT JOIN (
	SELECT month(accept_date) AS mon, COUNT(DISTINCT  requester_id, accepter_id) AS total_accepted
	FROM accepted_requests
    GROUP BY mon
) a ON r.mon = a.mon
WHERE IFNULL(a.total_accepted, 0) > 0
ORDER BY r.mon;
```

编写一个sql语句，找出拥有最多的好友的用户以及他拥有的好友数目，好友数相同时选择user_id较小的用户，结果返回用户编号user_id和好友数目friend_num

```
SELECT user_id,friend_num
FROM (
    SELECT user_id, COUNT(DISTINCT friend_id) AS friend_num
    FROM (
        SELECT requester_id AS user_id, accepter_id AS friend_id FROM accepted_requests
        UNION ALL
        SELECT accepter_id AS user_id, requester_id AS friend_id FROM accepted_requests
    ) AS all_friends
    GROUP BY user_id
) AS user_friend_count
ORDER BY user_friend_count.friend_num DESC, user_id ASC
LIMIT 1;
```



# 阅读记录

用户经常在网站上阅读文章，以下为记录阅读记录的表，

`views` 表：

```
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| article_id    | int     |
| author_id     | int     |
| viewer_id     | int     |
| view_date     | date    |
+---------------+---------+
此表无主键，因此可能会存在重复行。
此表包含读者的id，阅读的文章id，文章作者的id和阅读的日期。
请注意，同一人的 author_id 和 viewer_id 是相同的。
```

表的示例如下：

`views` 表：

```
+------------+-----------+-----------+------------+
| article_id | author_id | viewer_id | view_date  |
+------------+-----------+-----------+------------+
| 1          | 3         | 5         | 2019-08-01 |
| 1          | 3         | 6         | 2019-08-02 |
| 2          | 7         | 7         | 2019-08-01 |
| 2          | 7         | 6         | 2019-08-02 |
| 4          | 7         | 1         | 2019-07-22 |
| 3          | 4         | 4         | 2019-07-21 |
| 3          | 4         | 4         | 2019-07-21 |
+------------+-----------+-----------+------------+
```

编写一个sql语句，查询所有浏览过自己文章的作者，结果返回用户编号id，以id升序排列。          

```
SELECT DISTINCT viewer_id AS id
FROM views
WHERE author_id = viewer_id
ORDER BY id ASC
```

编写一个sql语句，找出曾在一天内阅读至少两篇文章的人，结果返回用户编号viewer_id，以viewer_id升序排列

```
SELECT viewer_id
FROM views
GROUP BY viewer_id, view_date
HAVING COUNT(DISTINCT article_id) >= 2
ORDER BY viewer_id ASC;
```

 编写一个sql语句，找出阅读文章总数最多的用户，阅读数量一样时选择view_id较小的用户，结果返回用户编号viewer_id和阅读文章数量article_num。

```
SELECT viewer_id, COUNT(article_id) AS article_num
FROM views
GROUP BY viewer_id
ORDER BY article_num DESC, viewer_id ASC
LIMIT 1;
```

编写一个sql语句，找出2020-08-01至2020-08-31期间阅读过3号作者文章的人，结果返回用户编号id，以id升序排列。 

```
SELECT DISTINCT viewer_id AS id
FROM views
WHERE author_id = 3
AND view_date BETWEEN '2020-08-01' AND '2020-08-31'
ORDER BY id ASC
```



# 网吧登录

用户在网吧使用机子时，会产生如下表，

`logins` 表：

```
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| user_id       | int     |
| client_id     | int     |
| login_date    | date    |
+---------------+---------+
id是该表的主键。
该表包含了该次登录的id号，登录用户的id，登录设备的id以及登录日期。
```

表的示例如下：

`logins` 表：

```
+--------+-----------+-----------+------------+
| id     |  user_id  | client_id | login_date |
+--------+-----------+-----------+------------+
| 1      | 1         | 2         | 2019-08-01 |
| 2      | 2         | 1         | 2019-08-02 |
| 3      | 3         | 3         | 2019-08-01 |
| 4      | 1         | 1         | 2019-08-02 |
| 5      | 5         | 2         | 2019-07-22 |
| 6      | 4         | 2         | 2019-07-21 |
| 7      | 4         | 4         | 2019-07-21 |
+--------+-----------+-----------+------------+
```

编写一个sql语句，查询每个用户最近一天登录的日子，结果返回用户编号user_id和登录日期date，以user_id升序排列。          

```
SELECT user_id, MAX(login_date) AS date
FROM logins
GROUP BY user_id
ORDER BY user_id;
```

编写一个sql语句，查询新登录用户的留存率，即新用户第1天登陆之后，第2天再次登陆的概率，结果返回留存率rate。

```
SELECT MIN(second.sec)*1.0/COUNT(DISTINCT l.user_id) AS rate
FROM(
  SELECT COUNT(DISTINCT first_date.user_id) AS sec
  FROM (
    SELECT l.user_id ,MIN(l.login_date) AS login_date
    FROM logins l
    GROUP BY l.user_id
  ) AS first_date
  WHERE EXISTS(
    SELECT 1
    FROM logins l1
    WHERE l1.user_id=first_date.user_id AND l1.login_date-first_date.login_date=1
  )
)AS second,logins AS l;
```

编写一个sql语句，查询登录新用户个数不少于2个的日期，结果返回日期login_date和登录新用户个数new_user_num，以login_date升序排序。 

```
SELECT first_login_date AS login_date, COUNT(user_id) AS new_user_num
FROM (
    SELECT user_id, MIN(login_date) AS first_login_date
    FROM logins
    GROUP BY user_id
) AS first_logins
GROUP BY first_login_date
HAVING COUNT(user_id) >= 2
ORDER BY first_login_date ASC;
```

编写一个sql语句，查询每个日期新用户次日留存率（包括留存率为0的日期），即该日登录的新用户第二日仍然登录的概率，返回日期date和留存率rate，保留小数点后3位，以date升序排列。          

```
SELECT d.date, ROUND(COALESCE(COUNT(DISTINCT l2.user_id) * 1.0 / NULLIF(COUNT(DISTINCT l1.user_id), 0), 0), 3) AS rate
FROM (SELECT DISTINCT login_date AS date FROM logins) d
LEFT JOIN 
    (SELECT user_id, MIN(login_date) AS first_login_date
     FROM logins
     GROUP BY user_id) AS l1 ON d.date = l1.first_login_date
LEFT JOIN 
    logins l2 ON l1.user_id = l2.user_id 
               AND l2.login_date = DATE_ADD(l1.first_login_date, INTERVAL 1 DAY)
GROUP BY d.date
ORDER BY d.date;
```



# 岗位成绩

一个公司的各个岗位，组织了考试让人参与，得到的表如下，

`grades` 表：

```
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
|  user_id      | int     |
|  job          | varchar |
|  score        | int     |
+---------------+---------+
user_id是该表的主键。
该表包含人员id，参与的岗位名称以及成绩
```

编写一个sql语句，查询各个岗位分数的平均数，结果返回岗位名称job以及平均成绩avg，保留小数点后3位，以avg降序排序。          

```
SELECT job, ROUND(AVG(score), 3) AS avg
FROM grades
GROUP BY job
ORDER BY avg DESC;
```

编写一个sql语句，查询分数大于其所在岗位平均分的用户，结果返回用户编号user_id，岗位名称job和该用户分数score，以user_id升序排序

```
SELECT g.user_id, g.job, g.score
FROM grades g
JOIN (
  SELECT job, AVG(score) AS avg_score
     FROM grades
     GROUP BY job
) t_avg
ON g.job = t_avg.job
WHERE g.score > t_avg.avg_score
ORDER BY g.user_id;
```

编写一个sql语句，查询各个岗位分数升序排列之后的中位数所在的位置start，end（范围从1开始，一个岗位参与人数为单数时 start = end，为偶数时 end = start + 1），以job升序排序

```
SELECT 
    job,
    FLOOR((COUNT(*) + 1) / 2) AS start_position,
    CEIL((COUNT(*) + 1) / 2) AS end_position
FROM (
    SELECT job, score
    FROM grades
    ORDER BY job, score
) AS sorted_grades
GROUP BY job
ORDER BY job;
```

编写一个sql语句，查询分数位于各个岗位中位数范围内的用户信息，结果返回用户编号user_id，岗位名称job，用户分数score和排名t_rank，以user_id升序排列

```
SELECT t1.user_id, t1.job, t1.score, t1.cnt as t_rank
FROM (SELECT g.user_id,
             g.job,
             g.score,
             (SELECT COUNT(*) FROM grades g1 WHERE g1.job = g.job AND g1.score >= g.score) as cnt
      FROM grades g) as t1 JOIN
     (SELECT g.job, CEIL(COUNT(*) / 2) as start, CEIL((1 + COUNT(*)) / 2) as end
      FROM grades g
      GROUP BY g.job
      ORDER BY g.job) as t2 ON t1.job = t2.job
WHERE t1.cnt = t2.start OR t1.cnt = t2.end
ORDER BY user_id;
```



# 公司职员2

公司员工信息和部门信息包含在以下两张表中，

有`employees`表，

```
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| name          | varchar |
| salary        | int     |
| department_id | int     |
+---------------+---------+
eno为该表主键。
该表包含员工的工号，姓名，工资，部门编号等信息
```

有`departments`表，

```
+-----------------+---------+
| Column Name     | Type    |
+-----------------+---------+
| department_id   | int     |
| departmant_name | varchar |
+-----------------+---------+
department_id为该表主键。
该表包含部门编号，部门名称等信息。
```

编写一个sql语句，查找Technology部门工资的平均值，结果返回部门名称department和平均工资avg_salary。          

```
SELECT
    d.department_name AS department,
    AVG(e.salary) AS avg_salary
FROM employees e
INNER JOIN departments d ON e.department_id = d.department_id
WHERE d.department_name = 'Technology'
GROUP BY d.department_name;
```

编写一个sql语句，查找各部门最高工资与最低工资的差值，结果返回部门名称department和差值sub

```
SELECT 
    d.department_name AS department,
    MAX(e.salary) - MIN(e.salary) AS sub
FROM employees e
JOIN departments d
ON e.department_id = d.department_id
GROUP BY d.department_id;
```

编写一个sql语句，获取各个部门第二高的薪水，结果返回部门名称department，员工姓名name和工资salary，以department_name升序排列

```
SELECT d.department_name AS department, e.name, e.salary
FROM employees e
JOIN departments d ON e.department_id = d.department_id
WHERE e.salary = (
	SELECT DISTINCT salary
	FROM employees
	WHERE department_id = e.department_id
	ORDER BY salary DESC
	LIMIT 1 OFFSET 1
)
order BY d.department_name;
```

编写一个sql语句，找出每个部门获得前三高工资的所有员工，结果返回部门名称department，员工姓名name和工资salary，以department升序，salary降序排列。 

```
SELECT d.department_name AS department, e.name, e.salary
FROM employees e
JOIN departments d ON e.department_id = d.department_id
WHERE (
	SELECT COUNT(DISTINCT higher.salary)
	FROM employees higher
	WHERE higher.department_id = e.department_id AND higher.salary > e.salary
) + 1 <= 3
ORDER BY department ASC, salary DESC;
```



# 参加活动情景

表: friends。
 id 是朋友的 id 和该表的主键。name 是朋友的名字。activity 是朋友参加的活动的名字

```
friends 表:
+------+--------------+---------------+
| id   | name         | activity      |
+------+--------------+---------------+
| 1    | Jonathan D   | eating        |
| 2    | Jade W       | singing       |
| 3    | Victor J     | singing       |
| 4    | Elvis Q      | singing       |
| 5    | Daniel A     | horse riding  |
| 6    | Bob B        | horse riding  |
+------+--------------+---------------+
```

表: activities。id 是该表的主键。name 是活动的名字。

```
activities 表:
+------------+--------------+-------------+-------------+
| ID         | activity     | startDate   | endDate     |
+------------+--------------+-------------+-------------+
| 1          | eating       | 2020-02-12  | 2020-02-20  |
| 2          | singing      | 2020-02-21  | 2020-02-23  |
| 3          | horse riding | 2020-02-24  | 2020-02-28  |
+------------+--------------+-------------+-------------+
```

查询那些既没有最多，也没有最少参与者的活动的名字，可以以任何顺序返回结果，activities 表的每项活动的参与者都来自friends 表。结果字段:activity           

```
SELECT activity
FROM (
  SELECT f.activity, COUNT(f.id) AS participant_count
  FROM friends f
  GROUP BY f.activity
) activity_counts
WHERE participant_count != (SELECT MAX(participant_count) FROM (
  SELECT f.activity, COUNT(f.id) AS participant_count
  FROM friends f
  GROUP BY f.activity
) max_counts)
AND participant_count != (SELECT MIN(participant_count) FROM (
  SELECT f.activity, COUNT(f.id) AS participant_count
  FROM friends f
  GROUP BY f.activity
) min_counts);
```

查询在2月20~2月28之间能进行的活动及参加该活动的朋友名字。结果字段包含name，activity。          

```
SELECT f.name AS name, f.activity 
FROM friends f
JOIN activities a ON f.activity = a.activity
WHERE 
    a.startDate BETWEEN "2020-02-20" AND "2020-02-28"
    AND a.endDate BETWEEN "2020-02-20" AND "2020-02-28"
```

查询进行eating的用户有哪些。结果字段：name          

```
SELECT name
FROM friends
WHERE activity = 'eating'
```

编写sql语句查询进行相同活动的用户的数量，要求结果字段有cnt（cnt表示用户的数量，依据题意至少为2），activity。结果字段：cnt，activity

```
SELECT COUNT(*) AS cnt, f.activity
FROM friends f
JOIN activities a ON f.activity = a.activity
GROUP BY f.activity
HAVING COUNT(*) >= 2;
```



# 电影相关情景

电影相关情景：

表：users。user_id 是表的主键。

```
+-------------+--------------+
| user_id     |  name        |
+-------------+--------------+
| 1           | Daniel       |
| 2           | Monica       |
| 3           | Maria        |
+-------------+--------------+
```

表：movies。movie_id 是这个表的主键。title 是电影的名字。

```
+-------------+--------------+
| movie_id    |  title       |
+-------------+--------------+
| 1           | Avengers     |
| 2           | Frozen 2     |
| 3           | Joker        |
+-------------+--------------+
```

表：movie_rating。(movie_id, user_id) 是这个表的主键。这个表包含用户在其评论中对电影的评分 rating 。
 created_at 是用户的点评日期。

```
+-------------+--------------+--------------+-------------+
| movie_id    | user_id      | rating       | created_at  |
+-------------+--------------+--------------+-------------+
| 1           | 1            | 3            | 2020-01-12  |
| 1           | 2            | 4            | 2020-02-11  |
| 1           | 3            | 2            | 2020-02-12  |
| 2           | 1            | 5            | 2020-02-17  | 
| 2           | 3            | 2            | 2020-03-01  |
| 3           | 1            | 3            | 2020-02-22  | 
+-------------+--------------+--------------+-------------+
```

查找在 2020 年 2 月 平均评分最高 的电影名称。 如果有相同的，返回字典序较小的电影名称。结果字段：title 

```
SELECT m.title
FROM movies m
JOIN movie_rating mr ON m.movie_id = mr.movie_id
WHERE mr.created_at BETWEEN '2020-02-01' AND '2020-02-29'
GROUP BY m.movie_id, m.title
ORDER BY AVG(mr.rating) DESC, m.title ASC
LIMIT 1;
```

查找评论电影数量最多的用户名。 如果出现平局，返回字典序较小的用户名。结果字段：name

```
SELECT u.name
FROM users u
JOIN movie_rating mr ON u.user_id = mr.user_id
GROUP BY u.name
ORDER BY COUNT(mr.movie_id) DESC, u.name ASC
LIMIT 1;
```

求每部电影的最高分，最低分以及平均分。结果字段包含movie_id, title, avg_rating, max_rating, min_rating。 

```
SELECT m.movie_id,  m.title, AVG(mr.rating) AS avg_rating, MAX(mr.rating) AS max_rating, MIN(mr.rating) AS min_rating
FROM movies m
JOIN movie_rating mr
ON m.movie_id = mr.movie_id
GROUP BY m.movie_id, m.title;
```

查询一月份评论过电影的用户。结果集包含，name , title, created_at。 

```
select u.name, m.title, mr.created_at
from users u
join movie_rating mr on u.user_id = mr.user_id
join movies m on mr.movie_id = m.movie_id
where mr.created_at like '2020-01%'
```

 查找用户id为1的用户看过的电影以及所给的评分。结果字段包含user_id，name，title，rating

```
SELECT u.user_id, u.name, m.title, mr.rating
FROM users u
JOIN movie_rating mr ON u.user_id = mr.user_id
JOIN movies m ON mr.movie_id = m.movie_id
WHERE u.user_id = 1;
```



# 发票相关情景

发票相关场景

顾客表：customers。customer_id 是这张表的主键。此表的每一行包含了某在线商店顾客的姓名和电子邮件。

```
customers table:
+-------------+---------------+------------------------+
| customer_id | customer_name | email                  |
+-------------+---------------+------------------------+
| 1           | Alice         | alice@smail.nju.edu.cn |
| 2           | Alex          | bob@smail.nju.edu.cn   |
| 13          | Bob           | john@smail.nju.edu.cn  |
| 6           | John          | alex@smail.nju.edu.cn  |
+-------------+---------------+------------------------+
```

联系方式表：contacts。(user_id, contact_email) 是这张表的主键。此表的每一行表示编号为 user_id 的顾客的某位联系人的姓名和电子邮件。此表包含每位顾客的联系人信息，但顾客的联系人不一定存在于顾客表中。

```
contacts table:
+-------------+--------------+------------------------+
| user_id     | contact_name | contact_email          |
+-------------+--------------+------------------------+
| 1           | Jal          | jal@smail.nju.edu.cn   |
| 2           | Omar         | omar@smail.nju.edu.cn  |
| 2           | Meir         | meir@smail.nju.edu.cn  |
| 6           | Alice        | alice@smail.nju.edu.cn |
+-------------+--------------+------------------------+
```

发票表：invoices。invoice_id 是这张表的主键。此表的每一行分别表示编号为 user_id 的顾客拥有有一张编号为 invoice_id、价格为 price 的发票。

```
invoices table:
+------------+-------+---------+
| invoice_id | price | user_id |
+------------+-------+---------+
| 77         | 100   | 1       |
| 88         | 200   | 1       |
| 99         | 300   | 2       |
| 44         | 60    | 6       |
+------------+-------+---------+
```

注意：小题中可能涉及到的一些字段解释：
 customer_name：与发票相关的顾客名称。
 price：发票的价格。
 contacts_cnt：该顾客的联系人数量。
 trusted_contacts_cnt：可信联系人的数量：既是该顾客的联系人又是商店顾客的联系人数量（即：可信联系人的电子邮件存在于客户表中）。

查询金额最大的发票所对应的发票号，用户ID，用户姓名。结果字段：invoice_id，price, user_id，customer_name

```
SELECT i.invoice_id, i.price, i.user_id, c.customer_name
FROM invoices i
JOIN customers c ON i.user_id = c.customer_id
WHERE i.price = (SELECT MAX(price) FROM invoices);
```

求拥有发票数大于1的用户的联系人名字及电子邮件。结果字段：user_id，contact_name，contact_email

```
SELECT c.user_id, c.contact_name, c.contact_email
FROM contacts c
WHERE c.user_id IN (
  SELECT i.user_id
  FROM invoices i
  GROUP BY i.user_id
  HAVING COUNT(i.invoice_id) > 1
);
```

求拥有一张发票的顾客及其电子邮箱。结果字段包含：user_id，customer_name，email

```
SELECT c.customer_id AS user_id, c.customer_name, c.email
FROM customers c
JOIN invoices i ON c.customer_id = i.user_id
GROUP BY c.customer_id, c.customer_name, c.email
HAVING COUNT(i.invoice_id) = 1;
```

求拥有联系人的顾客的id和姓名以及联系人姓名。结果字段customer_id，customer_name，contact_name

```
SELECT c.customer_id, c.customer_name, ct.contact_name
FROM customers c
JOIN contacts ct ON c.customer_id = ct.user_id;
```

为每张发票编写一个SQL查询，结果字段包含：invoice_id，customer_name，price，contacts_cnt（该顾客的联系人数量），trusted_contacts_cnt（可信联系人的数量）。查询的结果按照 invoice_id 排序

```
SELECT i.invoice_id, c.customer_name, i.price, COUNT(ct.contact_email) AS contacts_cnt, SUM(IF(ct.contact_email IN (SELECT email FROM customers), 1, 0)) AS trusted_contacts_cnt
FROM invoices i
JOIN customers c ON i.user_id = c.customer_id
LEFT JOIN contacts ct ON c.customer_id = ct.user_id
GROUP BY i.invoice_id, c.customer_name, i.price
ORDER BY i.invoice_id;
```



# 锦标赛情景

训练赛情景：

players 训练赛玩家表。玩家 ID 是此表的主键。此表的每一行表示每个玩家的组。注：每个组中可能既有男性又有女性。

```
players 表:
+-----------+------------+------------+
| player_id | player_name|  group_id  |
+-----------+------------+------------+
| 15        |   Joe      |      2     |
| 25        |  Alice     |      1     |   
| 30        |  Bajrang   |      1     |
| 45        |  Khali     |      1     |
| 10        |  Slaman    |      3     |
| 35        |  Aron      |      2     |
| 50        |  Priya     |      2     |
| 20        |   Jose     |      3     |
+-----------+------------+------------+
```

matches 训练赛赛事表。match_id 是此表的主键。
 每一行是一场比赛的记录，第一名和第二名球员包含每场比赛的球员 ID。
 第一个玩家和第二个玩家的分数分别包含第一个玩家和第二个玩家的分数。
 你可以假设，在每一场比赛中，球员都属于同一组。

```
matches 表:
+------------+--------------+---------------+-------------+--------------+
| match_id   | first_player | second_player | first_score | second_score |
+------------+--------------+---------------+-------------+--------------+
| 1          | 30           | 45            | 3           | 0            |
| 2          | 50           | 15            | 1           | 2            |
| 3          | 30           | 25            | 2           | 0            |
| 4          | 35           | 15            | 1           | 1            |
+------------+--------------+---------------+-------------+--------------+
```

表: scores。(gender, day)是该表的主键。该表独立于Matches表。是另一场模拟训练赛的比赛分数。
 该表的每一行表示一个名叫 (player_name) 性别为 (gender) 的参赛者在某一天获得了 (score_points) 的分数
 如果参赛者是女性，那么 gender 列为 ‘F’，如果参赛者是男性，那么 gender 列为 ‘M’

```
scores表:
+-------------+--------+------------+--------------+
| player_name | gender | day        | score_points |
+-------------+--------+------------+--------------+
| Aron        | F      | 2020-01-01 | 17           |
| Alice       | F      | 2020-01-07 | 23           |
| Bajrang     | M      | 2020-01-07 | 7            |
| Khali       | M      | 2019-12-25 | 11           |
| Slaman      | M      | 2019-12-30 | 13           |
| Joe         | M      | 2019-12-31 | 3            |
| Jose        | M      | 2019-12-18 | 2            |
| Priya       | F      | 2019-12-31 | 23           |
+-------------+--------+------------+--------------+
```

每组的获胜者是在组内累积得分最高的选手。若平局player_id 最小选手获胜。查询每组中的获胜者。结果字段包含group_id,player_id。 

```
SELECT ps.group_id, MIN(ps.player_id) AS player_id
FROM (
	SELECT
		p.group_id,
        p.player_id,
        IFNULL(SUM(
            CASE WHEN m.first_player = p.player_id THEN m.first_score ELSE 0 END +
            CASE WHEN m.second_player = p.player_id THEN m.second_score ELSE 0 END
        ), 0) AS total_score
    FROM players p
    LEFT JOIN matches m ON m.first_player = p.player_id OR m.second_player = p.player_id
    GROUP BY p.group_id, p.player_id
) AS ps
JOIN (
	SELECT ps2.group_id, MAX(ps2.total_score) AS max_total_score
	FROM (
		SELECT
			p2.group_id,
			p2.player_id,
			IFNULL(SUM(
				CASE WHEN m2.first_player = p2.player_id THEN m2.first_score ELSE 0 END +
				CASE WHEN m2.second_player = p2.player_id THEN m2.second_score ELSE 0 END
			), 0) AS total_score
		FROM players p2
		LEFT JOIN matches m2 ON m2.first_player = p2.player_id OR m2.second_player = p2.player_id
		GROUP BY p2.group_id, p2.player_id
	) AS ps2
    GROUP BY ps2.group_id
) AS max_scores ON ps.group_id = max_scores.group_id AND ps.total_score = max_scores.max_total_score
GROUP BY ps.group_id
ORDER BY ps.group_id ASC;
```

查询姓名为Aron的参赛者参加过的训练赛赛事分数。结果字段包含player_name ,match_id, score（不能为0）。 

```
SELECT 'Aron' AS player_name, m.match_id,
    CASE 
        WHEN m.first_player = p.player_id THEN m.first_score
        WHEN m.second_player = p.player_id THEN m.second_score
    END AS score
FROM matches m
JOIN players p ON (m.first_player = p.player_id OR m.second_player = p.player_id)
WHERE p.player_name = 'Aron'
    AND CASE 
            WHEN m.first_player = p.player_id THEN m.first_score
            WHEN m.second_player = p.player_id THEN m.second_score
        END > 0;
```

根据Scores表查询性别为‘F’在每一天的总分，并按性别和日期对结果排序。结果字段包含gender, day, total。

```
SELECT  s1.gender, s1.day, SUM(s2.score_points) AS total
FROM scores s1 
JOIN scores s2 ON s1.gender=s2.gender AND s1.gender = 'F' AND s1.day>=s2.day
GROUP BY s1.day
ORDER BY gender,s1.day;
```

 查询在1月进行训练赛的参赛者姓名，性别，分数。结果字段包含player_name ,gender, score_points。

```
SELECT player_name, gender, score_points
FROM scores
WHERE MONTH(day) = 1;
```

查找在scores表中获得最低分数的球员的姓名以及他的id。结果字段包含player_name, player_id，score_points.

```
SELECT p.player_name, p.player_id, s.score_points
FROM players p
JOIN scores s ON p.player_name = s.player_name
WHERE s.score_points = (
  SELECT MIN(score_points) FROM scores
);
```



# 商品订单情景

商品订单信息场景：

表：customers。customer_id 是该表主键，该表包含消费者的信息。

```
+-------------+-----------+
| customer_id | name      |
+-------------+-----------+
| 1           | Marwan    |
| 2           | John      |
| 3           | Anna      |
| 4           | Winston   |
+-------------+-----------+
```

表：orders。order_id 是该表主键，该表包含id为customer_id的消费者的订单信息。

每一个消费者 每天一笔订单，且没有顾客会在一天内订购相同的商品 **多于一次**。

```
orders
+----------+------------+-------------+------------+
| order_id | order_date | customer_id | product_id |  
+----------+------------+-------------+------------+
| 1        | 2020-07-31 | 1           | 1          |    
| 2        | 2020-07-30 | 2           | 2          |    
| 3        | 2020-08-29 | 3           | 3          |    
| 4        | 2020-07-29 | 4           | 1          |    
| 5        | 2020-06-10 | 1           | 2          |    
| 6        | 2020-08-01 | 2           | 1          |      
+----------+------------+-------------+------------+
```

表: products。product_id 是该表主键，该表包含所有商品的信息。

```
products
+------------+--------------+-------+
| product_id | product_name | price |
+------------+--------------+-------+
| 1          | keyboard     | 600   |
| 2          |  screen      | 800   |
| 3          |  mouse       | 200   |
| 4          | hard disk    | 450   |
+------------+--------------+-------+
```

查询顾客ID为1 的最近三笔订单。如果该用户订单少于 3 笔则返回其全部订单。结果按order_date 降序排列。结果字段：customer_name,customer_id,order_id,order_date

```
SELECT c.name AS customer_name, o.customer_id, o.order_id, o.order_date
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
WHERE o.customer_id = 1
ORDER BY o.order_date DESC
LIMIT 3;
```

找到每一个顾客最经常订购的商品。结果表单：每一位至少下过一次单的顾客id和他最经常订购的商品的ID和名字,按customer_id,product_id升序排列。结果字段：customer_id,product_id,p.product_name

```
SELECT cpo.customer_id, cpo.product_id, p.product_name
FROM (
  SELECT customer_id, product_id, COUNT(*) AS order_count
  FROM orders
  GROUP BY customer_id, product_id
) AS cpo INNER JOIN (
  SELECT customer_id, MAX(order_count) AS max_order_count
  FROM (
    SELECT customer_id, product_id, COUNT(*) AS order_count
    FROM orders
    GROUP BY customer_id, product_id
  ) AS counts
  GROUP BY customer_id
) AS max_counts ON cpo.customer_id = max_counts.customer_id
AND cpo.order_count = max_counts.max_order_count
INNER JOIN products p ON cpo.product_id = p.product_id
ORDER BY cpo.customer_id ASC, cpo.product_id ASC;
```

找到每件商品的最新订单(可能多个). 结果以商品名字升序排列。若相同则按商品id升序，再同以订单id 升序. 结果字段：product_name, product_id, order_id, order_date

```
SELECT p.product_name, p.product_id, o.order_id, o.order_date
FROM orders o
JOIN products p ON o.product_id = p.product_id
WHERE o.order_date = (
    SELECT MAX(order_date)
    FROM orders o2
    WHERE o2.product_id = o.product_id
)
ORDER BY p.product_name ASC, o.order_id ASC;
```

 查询在 2020 年 8 月份被卖出的产品名字。结果字段： product_name 

```
SELECT p.product_name
FROM orders o
JOIN products p ON p.product_id = o.product_id
WHERE o.order_date LIKE '2020-08%'
GROUP BY o.product_id
```

查询购买了产品ID 为1和产品 ID为2却没有购买产品ID为3的顾客的 ID 和姓名。结果字段： customer_id, name 

```
SELECT c.customer_id, c.name
FROM customers c
WHERE c.customer_id IN (
  SELECT customer_id
  FROM orders
  WHERE product_id = 1
) AND c.customer_id IN (
  SELECT customer_id
  FROM orders
  WHERE product_id = 2
) AND c.customer_id NOT IN (
  SELECT customer_id
  FROM orders
  WHERE product_id = 3
);
```



# 图书借阅情景

图书借阅情景：

表：books。存放图书相关信息。book_id是主键，代表图书号。sort是图书分类编号。output是出版社信息。

```
+------------+--------+--------------+----------+--------------+----------+
|  book_id   | sort   |  book_name   |  writer  | output       |  price   |
+------------+--------+--------------+----------+--------------+----------+
| 112266     | TP3/12 |   FoxBase    | 李三      | 电子工业出版社 |  23.600  |
| 113388     | TR7/90 |   大学英语    | 胡玲      | 清华大学出版社 |  12.500  |
| 114455     | TR9/12 |   线性代数    | 孙业      | 北京大学出版社 |  20.800  |
| 118801     | TP4/15 |   计算机网络  | 黄力钧     | 高等教育出版社 |  21.800  |
| 118802     | TP4/15 |   计算机网络  | 黄力钧     | 高等教育出版社 |  21.800  |
| 332211     | TP5/10 |   计算机基础  | 李伟       | 高等教育出版社 |  18.000  |
| 445501     | TP3/12 |   数据库导论  | 王强       | 科学出版社    |  17.900  |
| 445502     | TP3/12 |   数据库导论  | 王强       | 科学出版社    |  17.900  |
| 445503     | TP3/12 |   数据库导论  | 王强       | 科学出版社    |  17.900  |
| 446601     | TP4/13 |   数据库基础  | 马凌云     | 人民邮电出版社 |  22.500  |
| 665544     | TS7/21 |   高等数学    | 刘明      | 高等教育出版社  | 20.000  |
+------------+--------+------ -------+----------+---------------+---------+
```

表：readers。reader_id是主键。存放读者信息。其中company是读者的系，grade是读职称，addr是读者地址。

```
+------------+--------------+---------------+------+----------+----------+
| reader_id  | company      | name          | sex  |  grade   |  addr    |
+------------+--------------+---------------+-------------+--------------+
| 111        | 信息系        | 赵正义         |  女    |   教授   | 1号楼424 |
| 112        | 财会系        | 李丽           |  女    |   副教授 | 2号楼316 |
| 113        | 经济系        | 张三           |  男    |   讲师   | 3号楼105 |
| 114        | 信息系        | 周华发         |  男    |   讲师   |1号楼316  |
| 115        | 信息系        | 王小花         |  女    |   工程师 | 1号楼224 |
| 116        | 信息系        | 李明           |  男    |   副教授 | 1号楼318 |
| 117        | 计算机系      | 李小峰         |  男    |   助教   | 1号楼214 |
| 118        | 计算机系      | 许鹏飞         |  男    |   助工   | 1号楼216 |
| 119        | 计算机系      | 刘大龙         |  男    |   教授   | 1号楼318 |
+------------+--------------+---------------+-------------+---------------+
```

表：borrows。存放借阅信息。（reader_id, book_id）是主键。

```
+----------+------------+-------------+
|reader_id | book_id    | borrow_date |
+----------+------------+-------------+
| 111      | 445503     | 2006-08-21  |
| 111      | 112266     | 2006-03-14  |
| 112      | 445501     | 2006-03-09  |
| 112      | 449901     | 2006-10-23  |
| 112      | 665544     | 2006-10-21  |
| 115      | 449902     | 2006-08-21  |
| 118      | 118801     | 2006-09-10  |
+----------+-------------+------------+
```

找出与”赵正义”在同一天借书的读者姓名、所在单位及借书日期 。结果字段： name,company,borrow_date

```
SELECT r.name, r.company, b.borrow_date
FROM readers r
JOIN borrows b ON r.reader_id = b.reader_id
WHERE b.borrow_date IN (
    SELECT borrow_date
    FROM borrows
    JOIN readers ON borrows.reader_id = readers.reader_id
    WHERE readers.name = '赵正义'
)
AND r.name <> '赵正义';
```

查询财会系2006年7月以后没有借书的读者借书证号、姓名及单位。结果字段：reader_id,name,company 

```
SELECT r.reader_id, r.name, r.company
FROM readers r
WHERE r.company = '财会系'
AND r.reader_id NOT IN (
    SELECT DISTINCT b.reader_id
    FROM borrows b
    WHERE b.borrow_date >= '2006-07-01'
)
```

找出当前至少借阅了2本图书(大于等于2本)的读者姓名及其所在单位。结果字段：name,company 

```
SELECT r.name, r.company
FROM readers r
JOIN borrows b ON b.reader_id = r.reader_id
GROUP BY r.name, r.company
HAVING COUNT(DISTINCT b.book_id) >= 2;
```

找出作者为李某的书籍的被借阅情况。结果字段：writer, book_name, borrow_date

```
SELECT books.writer, books.book_name, borrows.borrow_date
FROM books
JOIN borrows ON borrows.book_id = books.book_id
WHERE books.writer LIKE '李%'
```

查找“高等教育出版社”的所有图书名称(BOOK_NAME)及单价(PRICE)，结果按单价降序排序。结果字段：book_name,price

```
SELECT DISTINCT book_name, price
FROM books
WHERE output = '高等教育出版社'
ORDER BY price DESC;
```



# 系统状态情景

系统状态情景：系统 **每天** 运行一个任务。每个任务都独立于先前的任务。任务的状态可以是失败或是成功。

表: failed。该表主键为 fail_date。该表包含任务失败的日期.

```
failed table:
+-------------------+----------------+
| fail_date         |  event_type    |
+-------------------+----------------+
| 2018-12-28        |   reviews      |
| 2018-12-29        |   ads          |
| 2019-01-04        |   ads          |
| 2019-01-05        |   reviews      |
+-------------------+----------------+
```

表: succeeded。该表主键为 success_date。该表包含任务成功的日期.

```
succeeded table:
+-------------------+---------------+
| success_date      |   event_type   |
+-------------------+---------------+
| 2018-12-30        |   page views  |
| 2018-12-31        |   page views  |
| 2019-01-01        |   ads         |
| 2019-01-02        |   ads         |
| 2019-01-03        |   reviews     |
| 2019-01-06        |   reviews     |
+-------------------+---------------+
```

事件表：events。该表是一个独立于前两个表的表。此表的主键是 (business_id, event_type)。表中的每一行记录了某种类型的事件在某些业务中多次发生的信息。

```
events table:
+-------------+------------+------------+
| business_id | event_type | occurences |
+-------------+------------+------------+
| 1           | page views | 7          |
| 1           | reviews    | 3          |
| 2           | ads        | 11         |
| 2           | reviews    | 3          |
| 3           | page views | 12         |
+-------------+------------+------------+
```

注：和小题相关的一个解释：
 如果一个业务的某个事件类型的发生次数（字段occurences）大于此事件类型在所有业务中的平均发生次数，并且该业务至少有两个这样的事件类型，那么该业务就可被看做是活跃业务。

查询2019-01-01到2019-12-31期间任务连续同状态的起止日期。如果任务失败/成功就是失败/成功状态的起止日期。结果按照起始日期排序。结果字段：period_state，start_date，end_date 

```
SELECT DISTINCT s1.*
FROM Stadium s1
JOIN Stadium s2 ON s1.id = s2.id - 1
JOIN Stadium s3 ON s2.id = s3.id - 1
WHERE s1.people >= 100 AND s2.people >= 100 AND s3.people >= 100

UNION

SELECT DISTINCT s2.*
FROM Stadium s1
JOIN Stadium s2 ON s1.id = s2.id - 1
JOIN Stadium s3 ON s2.id = s3.id - 1
WHERE s1.people >= 100 AND s2.people >= 100 AND s3.people >= 100

UNION

SELECT DISTINCT s3.*
FROM Stadium s1
JOIN Stadium s2 ON s1.id = s2.id - 1
JOIN Stadium s3 ON s2.id = s3.id - 1
WHERE s1.people >= 100 AND s2.people >= 100 AND s3.people >= 100

ORDER BY visit_date;
```

查询所有活跃的业务。结果字段只包含business_id。 

```
SELECT e.business_id
FROM events e
JOIN (
  SELECT event_type, AVG(occurences) AS avg_occurences
  FROM events
  GROUP BY event_type
) ea ON e.event_type = ea.event_type
WHERE e.occurences > ea.avg_occurences
GROUP BY e.business_id
HAVING COUNT(e.event_type) >= 2;
```

分别求出每个event事件的成功天数与失败天数。结果字段包含：event_type，success_count，fail_count

```
SELECT
    et.event_type,
    COALESCE(s.success_count, 0) AS success_count,
    COALESCE(f.fail_count, 0) AS fail_count
FROM
    (
        SELECT DISTINCT event_type FROM failed
        UNION
        SELECT DISTINCT event_type FROM succeeded
    ) AS et
LEFT JOIN
    (
        SELECT event_type, COUNT(*) AS success_count
        FROM succeeded
        GROUP BY event_type
    ) AS s ON et.event_type = s.event_type
LEFT JOIN
    (
        SELECT event_type, COUNT(*) AS fail_count
        FROM failed
        GROUP BY event_type
    ) AS f ON et.event_type = f.event_type
ORDER BY
    et.event_type;
```

求出reviews事件在18年12月份系统里的最小的失败次数。结果字段：occurences，event_type，fail_count

```
SELECT
    MIN(e.occurences) AS occurences,
    'reviews' AS event_type,
    (SELECT COUNT(*) FROM failed f
     WHERE f.event_type = 'reviews'
       AND f.fail_date >= '2018-12-01'
       AND f.fail_date < '2019-01-01') AS fail_count
FROM
    events e
WHERE
    e.event_type = 'reviews';
```

求一下事件类型发生次数最多的商业ID。结果字段仅包含business_id。 

```
SELECT business_id
FROM events
ORDER BY occurences DESC
LIMIT 1;
```



# 学生选课情景

学生选课情景：

学生表：students。s_id是主键。

```
+-------------+--------+------------+--------------+
| s_id        | s_name |  s_birthday| s_sex        |
+-------------+--------+------------+--------------+
| 1           | 赵雷    | 1990-01-01 | 男           |
| 2           | 钱电    | 1990-12-21 | 男           |
| 3           | 孙风    | 1990-05-20 | 男           |
| 4           | 李云    | 1990-08-06 | 男           |
| 5           | 周梅    | 1991-12-01 | 女           |
| 6           | 吴兰    | 1992-03-01 | 女           |
+-------------+--------+------------+--------------+
```

课程表：courses.。c_id是主键。

```
+--------+------------+---------+
| c_id   |  c_name    |   t_id  |
+--------+------------+---------+
| 1      | 英语        |    2    |
| 2      | 数学        |    1    |
| 3      | 语文        |    3    |
+--------+-------------+--------+
```

教师表：teachers。t_id是主键。

```
+--------+------------+
| t_id   |  t_name    | 
+--------+------------+
| 1      | 张三        | 
| 2      | 李四        | 
| 3      | 王五        | 
+--------+------------+
```

成绩表scores。（s_id, c_id）是主键。

```
+--------+------------+---------+
|  s_id  |   c_id     | s_score |
+--------+------------+---------+
| 1      | 1          | 80      |
| 1      | 2          | 90      |
| 1      | 3          | 99      |
| 2      | 1          | 70      |
| 2      | 3          | 60      |
| 3      | 2          | 80      |
| 3      | 3          | 80      |
| 4      | 1          | 50      |
| 4      | 2          | 30      |
| 4      | 3          | 20      |
| 5      | 1          | 76      |
| 6      | 1          | 31      |
| 6      | 3          | 34      |
+--------+------------+---------+
```

查询没有学全所有课程的同学的信息。结果字段包含s_id, s_name, s_birthday, s_sex

```
SELECT s.s_id, s.s_name, s.s_birthday, s.s_sex
FROM students s
WHERE s.s_id IN (
    SELECT s_id
    FROM scores
    GROUP BY s_id
    HAVING COUNT(DISTINCT c_id) < (SELECT COUNT(*) FROM courses)
);
```

 查询课程号为1和2，成绩在第3到第5名的学生信息及该课程成绩。结果字段包含：s_id, s_name, s_birthday, s_sex, _rank, s_score, c_id。查询结果按课程号、成绩升序排列。 

```
SELECT 
	s.s_id,
    s.s_name,
    s.s_birthday,
    s.s_sex,
    COUNT(sc2.s_score) + 1 AS _rank,
    sc1.s_score,
    sc1.c_id
FROM scores AS sc1
JOIN scores AS sc2 ON sc1.c_id = sc2.c_id AND sc1.s_score < sc2.s_score
JOIN students AS s ON sc1.s_id = s.s_id
WHERE sc1.c_id IN (1, 2)
GROUP BY sc1.c_id, sc1.s_id, s.s_name, s.s_birthday, s.s_sex, sc1.s_score
HAVING _rank BETWEEN 3 AND 5
ORDER BY sc1.c_id, _rank;
```

 查询各科成绩最高分，最低分，不及格率，中等率和优秀率。结果字段包含：c_id，c_name，max_score，min_score，'不及格率'，'中等率'和'优秀率'（及格率、中等率和优秀率结果在0到1之间，保留两位小数）。注：不及格<60，中等>=60且<90，优秀>=90。 

```
SELECT 
    c.c_id,
    c.c_name,
    MAX(s.s_score) AS max_score,
    MIN(s.s_score) AS min_score,
    ROUND(SUM(CASE WHEN s.s_score < 60 THEN 1 ELSE 0 END) * 1.0 / COUNT(s.s_score), 2) AS '不及格率',
    ROUND(SUM(CASE WHEN s.s_score >= 60 AND s.s_score < 90 THEN 1 ELSE 0 END) * 1.0 / COUNT(s.s_score), 2) AS '中等率',
    ROUND(SUM(CASE WHEN s.s_score >= 90 THEN 1 ELSE 0 END) * 1.0 / COUNT(s.s_score), 2) AS '优秀率'
FROM scores s
JOIN courses c ON s.c_id = c.c_id
GROUP BY c.c_id, c.c_name;
```

统计各科成绩各分数段人数：课程编号,课程名称,[100-85),[85-70),[70-60),[0-60]及所占百分比。结果字段：c_name, c_id，85-100, percent, 70-85, percent, 60-70, percent, 0-60, percent。

```
SELECT
	c.c_name, 
    c.c_id,
    SUM(CASE WHEN s.s_score > 85 AND s.s_score <= 100 THEN 1 ELSE 0 END) AS '85-100',
    ROUND(SUM(CASE WHEN s.s_score > 85 AND s.s_score <= 100 THEN 1 ELSE 0 END)* 100.0 / COUNT(s.s_score),2)  AS 'percent',
    SUM(CASE WHEN s.s_score > 70 AND s.s_score <= 85 THEN 1 ELSE 0 END) AS '70-85',
    ROUND(SUM(CASE WHEN s.s_score > 70 AND s.s_score <= 85 THEN 1 ELSE 0 END) * 100.0 / COUNT(s.s_score),2)AS 'percent',
    SUM(CASE WHEN s.s_score > 60 AND s.s_score <= 70 THEN 1 ELSE 0 END) AS '60-70',
    ROUND(SUM(CASE WHEN s.s_score > 60 AND s.s_score <= 70 THEN 1 ELSE 0 END)* 100.0 / COUNT(s.s_score),2)  AS 'percent',
    SUM(CASE WHEN s.s_score <=60 THEN 1 ELSE 0 END) AS '0-60',
    ROUND(SUM(CASE WHEN s.s_score <=60 THEN 1 ELSE 0 END)* 100.0 / COUNT(s.s_score),2)  AS 'percent'
FROM courses c
JOIN scores s ON c.c_id = s.c_id
GROUP BY c.c_id, c.c_name;
```

查询没学过张三老师讲授的任一门课程的学生姓名。结果字段：s_name

```
SELECT s.s_name
FROM students s
WHERE s.s_id NOT IN (
    SELECT DISTINCT sc.s_id
    FROM scores sc
    JOIN courses c ON sc.c_id = c.c_id
    WHERE c.t_id = (SELECT t_id FROM teachers WHERE t_name = '张三')
);
```



# 公司部门职员情景

`employee` 表包含所有员工信息，每个员工有其对应的工号 `Id`，姓名 `Name`，工资 `Salary` 和部门编号 `DepartmentId` 。他们的经理也属于员工。每个员工还有一列对应员工的经理的 Id。

employee：

```
+----+-------+--------+--------------+-------------+
| Id | Name  | Salary | DepartmentId |  ManagerId  |
+----+-------+--------+--------------+-------------+
| 1  | Joe   | 84000  | 1            |    4        |  
| 2  | Henry | 80000  | 2            |    8        |   
| 3  | Sam   | 60000  | 2            |    8        |
| 4  | Max   | 120000 | 1            |    null     |
| 5  | Janet | 69000  | 2            |    8        |
| 6  | Randy | 85000  | 1            |    4        |
| 7  | Will  | 70000  | 1            |    4        |
| 8  | Jim   | 131000 | 2            |    null     |
+----+-------+--------+--------------+-------------+
```

`department` 表包含公司所有部门的信息。

```
+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+
```

查询每个部门工资最高的员工，结果字段包含：department_name,employee,salary

```
SELECT d.Name AS department_name, e.Name AS employee, e.Salary
FROM employee e
JOIN department d ON e.DepartmentId = d.Id
WHERE e.Salary = (
    SELECT MAX(Salary)
    FROM employee e2
    WHERE e2.DepartmentId = e.DepartmentId
);
```

查询收入超过他们经理的员工的姓名。结果字段:employee

```
SELECT e.Name AS Employee
FROM employee e
JOIN employee m ON e.ManagerId = m.Id
WHERE e.Salary > m.Salary;
```

查询职员表中第二高的薪水（注：若AB薪资都是3000，C薪资2000，则第二高指的是C的2000）。结果字段：SecondHighestSalary

```
SELECT MAX(Salary) AS SecondHighestSalary
FROM employee
WHERE Salary < (SELECT MAX(Salary) FROM employee);
```

编写SQL查询来查找每个部门的薪水中位数。若某一部门薪水情况是：1000,2000,3000,4000，则中位数为2000及3000.结果字段：departmentId, salary

```
SELECT DepartmentId, Salary
FROM (
    SELECT 
        e1.DepartmentId,
        e1.Salary,
        (SELECT COUNT(*) FROM employee e2 
         WHERE e2.DepartmentId = e1.DepartmentId AND e2.Salary <= e1.Salary) AS RankInDept,
        (SELECT COUNT(*) FROM employee e2 
         WHERE e2.DepartmentId = e1.DepartmentId) AS NumEmployees
    FROM employee e1
) AS t
WHERE
    (NumEmployees % 2 = 1 AND RankInDept = (NumEmployees + 1) DIV 2)
    OR
    (NumEmployees % 2 = 0 AND RankInDept IN ((NumEmployees) DIV 2, (NumEmployees DIV 2) + 1))
ORDER BY DepartmentId, Salary;
```



# 薪资等级情景

表：dept。deptno是主键，dname是部门名称，loc是部门地址。

```
+--------+------------+---------+
| deptno |  dname     |  loc    |
+--------+------------+---------+
| 10     | Accounting | new york|
| 20     | Research   | dallas  |
| 30     | Sales      | chicago |
| 40     | Operations | boston  |
+--------+-------------+--------+
```

表：emp。job是员工工作，mgr是员工直属领导编号，可以为空。hiredate员工入职时间。sal是员工月薪工资，comm是奖金。

```
+----------+--------------+---------------+-------+-------------+-------+-----+---------+
| empno    | ename        | job           | mgr   | hiredate    | sal   | comm | deptno |
+----------+--------------+---------------+-------+-------------+-------+------+--------+
| 7369     | smith        | CLERK         | 7902  | 1980-12-17  | 800   | NULL | 20     |
| 7566     | jones        | manager       | 7839  | 1981-04-02  | 2975  | NULL | 20     |
| 7654     | martin       | salesman      | 7698  | 1981-09-28  | 1250  | 1400 | 30     |
| 7698     | blake        | manager       | 7839  | 1981-05-01  | 2850  | NULL | 30     |
| 7782     | clark        | manager       | 7839  | 1981-06-09  | 2450  | NULL | 10     |
| 7839     | king         | president     | null  | 1981-11-17  | 5000  | 2000 | 10     |
| 7844     | turner       | salesman      | 7698  | 1981-09-08  | 1500  | 800  | 30     |
| 7900     | james        | CLERK         | 7698  | 1981-12-03  | 950   | NULL | 30     |
| 7902     | ford         | analyst       | 7566  | 1981-12-03  | 3000  | NULL | 20     |
| 7934     | miller       | CLERK         | 7782  | 1981-01-23  | 1300  | NULL | 10     |
+----------+--------------+---------------+-------+-------------+-------+------+--------+
```

表：salGrade。 grade是等级，losal是最低工资，hisal是最高工资 。

```
+--------+------------+---------+
| grade  |  losal     |  hisal  |
+--------+------------+---------+
| 1      |  700       |  1000   |
| 2      |  1001      |  1400   |
| 3      |  1401      |  2000   |
| 4      |  2001      |  4000   |
| 5      |  4001      |  9999   |
+--------+-------------+--------+
```

查询工资高于部门号为30的所有员工工资水平的员工信息。 结果字段：empno，ename，job，mgr，hiredate，sal，comm，deptno。 

```
SELECT empno, ename, job, mgr, hiredate, sal, comm, deptno
FROM emp
WHERE sal > (SELECT MAX(sal) FROM emp WHERE deptno = 30);
```

返回工资处于第四级别的员工的姓名。结果字段包含：ename，sal。 

```
SELECT ename, sal
FROM emp
WHERE sal BETWEEN '2001' AND '4000'
```

返回工资为二等级的职员名字、部门名称、工资和二等级的最低工资和最高工资 。结果字段： ename，dname，sal，losal，hisal。 

```
SELECT e.ename, d.dname, e.sal, s.losal, s.hisal
FROM emp e
JOIN dept d ON e.deptno = d.deptno
JOIN salGrade s ON e.sal BETWEEN s.losal AND s.hisal
WHERE s.grade = 2;
```

返回工资等级高于smith且直属领导编号为7698的员工信息。结果字段：empno，ename，job，mgr，hiredate，sal，comm，deptno。 

```
SELECT e.empno, e.ename, e.job, e.mgr, e.hiredate, e.sal, e.comm, e.deptno
FROM emp e
JOIN salGrade s ON e.sal BETWEEN s.losal AND s.hisal
WHERE s.grade > (
    SELECT s2.grade
    FROM emp e2
    JOIN salGrade s2 ON e2.sal BETWEEN s2.losal AND s2.hisal
    WHERE e2.ename = 'smith'
)
AND e.mgr = 7698;
```

计算出部门号为20的员工的年薪，并且对年薪进行升序排序。结果字段包含ename，deptno，ySalary

```
SELECT e.ename, e.deptno, (e.sal * 12) AS ySalary
FROM emp e
WHERE e.deptno = 20
ORDER BY ySalary ASC;
```



# Tom 和 Jerry 的存款

有如下表：

`blank_data`表：

```
+----+-------+--------+
| id | name  | amount |
+----+-------+--------+
| 1  | Tom   | ?      |
| 2  | Jerry | ?      |
+----+-------+--------+
```

`address_data`表：

```
+-------+---------+
| name  | address |
+-------+--------+
| Tom   | ?       |
| Jerry | ?       |
+-------+---------+
```

 查询Tom和Jerry的存款，结果返回姓名name，存款amount

```
SELECT bd.name, bd.amount
FROM blank_data bd
WHERE bd.name IN ('Tom', 'Jerry');
```

查询Tom和Jerry的地址，结果返回姓名name，地址address

```
SELECT ad.name, ad.address
FROM address_data ad
WHERE ad.name IN ('Tom', 'Jerry');
```

