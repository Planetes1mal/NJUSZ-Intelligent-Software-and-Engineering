# SQL 优化

## SQL 优化的基础

### 关系代数

关系代数：表达式的等价变换

关系（表）、关系操作

关系代数表达式可以通过等价变换优化执行路径

关系代数提供了一种形式化的方法，使得 SQL 查询可以转化为标准的关系表达式，再通过优化器选择最优路径来执行查询。

作用：使关系型数据库具备科学基础

- 关系型数据库管理系统（RDBMS）的操作不需要关心实现细节

- 理论支持数据库的设计，提供普遍规则

### SQL 与查询优化器

**查询优化器的工作原理**

优化器借助关系理论提供的语义无误的原始查询，进行有效的等价变换，生成不同的关系代数表示，并在这些表示中选择执行成本最低的路径。

优化器根据数据库的实际实现情况，对理论上等价的不同方案进行权衡，以找到最优执行路径。最终输出可能的最优查询执行方案，即成本最低的关系代数表达式。

目标：将一个SQL查询优化为更高效的执行方案，尽可能减少计算资源的使用。

#### 基于规则的优化器和算法

通过匹配关系代数表达式中的局部结构，根据规则替换部分操作。

局限性：

- 规则选择：需要决定哪些规则应用、应用顺序。
- 效果评估：难以评估优化后性能的提升。
- 通用性下降：规则具有较大的适配范围局限性。

一般固定规则的优先级由人工设定，存在一定限制。

#### 基于成本的优化器和算法

不重复地遍历所有不同的关系代数表示，枚举功能。

每⼀次变化都使用了不同的规则，应用了某种规则后还可以使用其他规则，直到所有变化都被穷尽，只要可以计算出所有可能的变化，就可以得到最优方案

**基于成本优化器的实现**

- Volcano 模型：提供了一套用于SQL解析和执行的接口，支持SQL查询的解析和执行任务
  - 优点：流行性高，许多Apache项目都使用它完成SQL解析与执行。
    缺点：文档不足，学习和理解门槛较高。

- 实现基础知识
  - **贪心算法：**快速选择局部最优解。
    **动态规划：**系统性枚举所有可能执行路径，从中选取最优解。
    **广度优先搜索：**遍历所有可能的代数表达式变化。
    **启发式算法：**利用启发规则减少搜索空间，提高优化效率。

## 数据的基本访问方式

### 优化的主要方向：连接

连接查询是 SQL 优化的关键环节

优化器的目标是减少连接的I/O成本和CPU成本，从而提高查询效率

**驱动表和被驱动表**

**驱动表**是连接查询的起点，被驱动表需要与驱动表进行匹配。

驱动表通常只访问一次，而被驱动表的访问次数取决于驱动表结果集的大小。

### 嵌套循环连接（Nested-Loop Join）

工作原理：对驱动表中的每一条记录，扫描被驱动表，找出满足条件的记录。

驱动表只访问一次，被驱动表可能多次访问，具体次数取决于对驱动表执行单表查询后的结果集中的记录条数

使用索引加速连接：

- 被驱动表有索引：被驱动表的每一次访问都会利用索引定位所需的数据块，从而减少磁盘I/O
- 多个条件查询时：优化器会选择一个最优索引进行查询，因此尽量设计覆盖主要查询条件的复合索引。

- 避免全表扫描：尽量不要使用 `SELECT *`，而是明确需要查询的列。


### 基于块的连接优化（Block Nested-Loop Join）

块嵌套循环连接通过减少被驱动表的访问次数来优化查询性能

工作方式：将驱动表的部分记录加载到 `join buffer` 中，一次性访问被驱动表进行匹配

`join buffer` 的大小通常有限（例如256KB），过大的驱动表可能会导致效率下降

如果被驱动表很大且被多次访问，优先考虑使用索引，而不是依赖 `join buffer`

## 查询成本分析

### 什么是“成本”

I/O成本：数据库从磁盘加载数据到内存的过程，涉及“物理读写”。物理读取一个页面的默认成本设为1.0。

CPU成本：检测记录是否满足查询条件，以及对结果集的排序。默认逻辑读取成本设为0.2。

### 基于成本的优化步骤

1. 根据搜索条件，找出所有可能使用的索引

2. 计算全表扫描的代价：公式：`页面数量 = Data_length / 页面大小`

3. 计算使用不同索引的代价

   - 示例：

     ```
     SELECT *
     FROM single_table
     WHERE
     	key1 IN ('a', 'b', 'c') AND
     	key2 > 10 AND key2 < 1000 AND
     	key3 > key2 AND
     	key_part1 LIKE '%hello%' AND
     	common_field = '123';
     ```

     `Row = 9693，Data_length = 1589248`，页面大小为 `16KB`：页面数量 = 1589248 / 16 / 1024 = 97
     I/O 成本：`97 × 1.0 + 1.1 = 98.1`
     CPU 成本：`9693 × 0.2 + 1.0 = 1936.6`
     总成本：`98.1 + 1936.6 = 2037.7`
     `使用 uk_key2 的成本 = 134.1`，`使用 idx_key1 的成本 = 168.1`。

### 两表连接的成本分析

连接查询的总成本 = 单次访问驱动表的成本 + (驱动表扇出值 × 单次被驱动表的成本)

优化器会根据驱动表的扇出值预测和单表访问成本，选择总成本最低的方案。

多表连接：可选路径的数量呈指数增长，复杂度较高。

### 调节成本常数

调节系统变量可以优化连接顺序和连接深度

不考虑连接顺序时，可以使用启发式规则或调节变量约束深度



## 查询优化的关键技术

### 查询优化器的作用

实现关系代数的化简和优化。根据实际的数据库物理特性选择最优的执行路径。

**关键影响因素**：

- 存储设备的特性：
  - 顺序读取与随机读取的性能差异
  - 存储设备的吞吐量对执行性能的影响
- 存储结构的基本特征：
  - 列式存储和行式存储的差异
  - 是否存在列分区或分片等结构优化
- 元数据和预计算结果：包括索引和物化视图等
- 聚合和计算单元的特性：
  - 单线程与并发处理的效率对比
  - 分布式架构的优势
  - 硬件加速对性能的提升作用

### SQL 的执行顺序

SQL的主要任务：说明需要完成的目标（声明性语言）

优化器的主要任务：决定如何实现目标，生成高效的执行计划

执行流程：

- 语法检查：检查SQL语句的语法是否正确。
- 解析：将SQL语句解析为关系代数的表达式。
- 执行计划生成：由查询优化器生成基于关系代数优化后的执行路径。
- 执行引擎：按照优化器生成的计划执行查询。
- 存储引擎：负责从底层存储设备中提取数据，完成最终的查询结果。

### 优化器的自动条件化解

1. 移除不必要的括号：去掉多余的嵌套，减少解析器的额外工作量，使查询结构更简单

   ```
   SELECT * FROM (t1, (t2, t3)) WHERE t1.a = t2.a AND t2.b = t3.b;
   SELECT * FROM t1, t2, t3 WHERE t1.a = t2.a AND t2.b = t3.b;
   ```

2. 常量传递：在查询条件中，将常量表达式进行直接替换

   - 对于涉及 OR 操作符的表达式，优化器无法进行常量传递

   ```
   a = 5 AND b > a;
   a = 5 AND b > 5;
   ```

3. 移除无用的条件：去掉无效或不可能为真的条件

   ```
   (a < 1 AND b = b) OR (a = 6 OR 5 != 5);
   a < 1 OR a = 6;
   ```

4. 表达式计算

   ```
   a = 5 + 1;
   a = 6;
   ```

   - 对于某些复杂表达式，如 `-a < -8`，优化器不会进行化简。原因可能涉及数据类型、溢出问题或平台实现差异

5. 合并 HAVING 子句和 WHERE 子句：当查询中没有聚合函数（如 `SUM`、`MAX`）或 `GROUP BY` 子句时，`HAVING` 和 `WHERE` 子句可以合并

6. 常量表检查：

   - 如果表中只有一条记录，则优化器直接将表替换为常量计算
   - 应用场景：使用主键或者唯一的二级索引键的等值查询

## 使用 SQL 需要考虑的因素

### 数据总量

SQL 查询性能的关键在于必须访问的数据总量。如果访问数据量过大，查询效率会显著下降。

在没有清楚的目标容量之前，很难准确断定查询执行的效率

### 查询条件

过滤条件（`WHERE` 子句）的效率可能受多种因素影响，如过滤条件、主要SQL语句、庞大的数据量对查询的影响等

当SQL中包含多个嵌套查询或视图时，`WHERE` 子句可能会重复出现。

### 结果集大小

查询结果集的大小直接影响用户体验

结果集大小本身对查询效率的影响有限，真正关键的是访问数据的范围

需要确保查询响应时间与结果数量成比例

### 表的数量

SQL 查询中的表数量越多，性能受影响越大

随着表数量的增加，连接的复杂度呈指数增长，这给优化器的选择带来了挑战

如果一个查询需要连接过多的表（如超过5个），应重新审视设计，避免复杂查询造成的性能瓶颈

如果视图返回的数据远多于上层查询需要的数据，会导致性能问题。当视图返回的数据远多于上级查询所需要的时候，就放弃使用该视图

### 并发用户数

在高并发场景下，SQL 查询需要考虑多个用户同时访问同一资源时可能带来的资源争用问题

- 数据块访问争用（Block-Access Contention）：多用户竞争访问相同的数据块，导致性能下降。
- 阻塞（Locking）：事务中的锁机制可能造成访问延迟。
- 闩定（Latching）：多线程争用共享资源时的短期锁，可能导致响应时间变长。

- 一致性要求：保证读取的一致性


## 查询的过滤条件

过滤条件可以存在于多个 SQL 语句的组成部分中，包括以下场景：

- WHERE 子句：用于直接过滤满足特定条件的数据。
- HAVING 子句：通常用于过滤聚合结果。
- JOIN 过滤条件：在表连接中，限制连接条件以减少无关数据的匹配。
- SELECT 过滤条件：对返回的列内容进行进一步筛选。

好过滤条件的特点：

1. 清晰目标：明确需要的数据是什么，来自哪些表。
2. 有效过滤：条件能够尽可能过滤掉不必要的数据，减少数据传输量。

不良过滤条件的危害：

- 无效条件会导致大量无用数据进入查询过程，浪费资源。
- 条件复杂度过高时，优化器可能无法有效简化或选择最佳执行路径。

高效过滤条件的重要性：高效过滤条件是查询的主要驱动力，直接决定查询性能。

**进一步优化过滤条件**

- 非关联子查询：不依赖外层查询，独立执行。

- 嵌套子查询：通过进一步嵌套的方式，将复杂逻辑分解为多个简单的步骤



## 子查询优化

### 子查询分类

1. 按返回结果集分类
   - 标量子查询：返回单一值的子查询
   - 行子查询：返回单条记录的子查询，包含多列
   - 列子查询：返回单列多行数据的子查询
   - 表子查询：返回多行多列结果的子查询
2. 按与外层查询的关系分类
   - 不相关子查询：子查询独立于外层查询，可单独执行
   - 相关子查询：子查询依赖于外层查询，需要每次与外层查询的当前行关联

### `ANY` 和 `ALL` 关键字的使用

1. `ANY` 或 `SOME`：如果子查询结果集中存在任意一条记录满足条件，则表达式为 `TRUE`
2. `ALL`：如果子查询结果集中所有记录都满足条件，则表达式为 `TRUE`

### 标量子查询与 IN 子查询优化

1. 标量子查询的优化：标量子查询的优化方式是在单个值的计算基础上进行优化。标量子查询只需要计算一次，优化器可以直接将其结果与外层查询整合
2. IN 子查询的优化：
   - 子查询结果集较小：优化器将内外层分别优化，直接将子查询结果与外层查询进行匹配
   - 子查询结果集较大：当结果集较大且无法完全加载到内存中时，优化器会采取以下措施：
     - 写入临时表：将子查询结果存储到内存中的临时表中
     - 去重：对子查询结果去重，以减少外层查询的匹配次数
     - 构建哈希索引：通过构建哈希索引来加速匹配过程
   - 子查询结果集过大：如果结果集大到内存临时表无法存放，优化器将结果写入磁盘上的物化表，并构建 B+ 树索引以提高效率。

**进一步优化方式**：半连接（Semi-Join）：将外层表和物化表之间的连接转化为半连接，减少不必要的数据传输



