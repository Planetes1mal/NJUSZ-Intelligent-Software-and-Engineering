# 2 开发成功数据库应用的要点

**数据库体系结构的差异**

不能把数据库当成“黑盒”使用，因为每个数据库都是非常不同的

了解这种差异，了解你所使用数据库的特性，是开发成功数据库应用的基础

## 锁机制与并发控制

不同的数据库，实现锁机制是不一样的

从体系结构和特性中了解具体数据库的锁机制

Oracle 实现的锁机制：只有修改才加行级锁、Read绝对不会对数据加锁、Writer 不会阻塞 Reader、读写器绝对不会阻塞写入器

## 数据库体系结构

Oracle的无阻塞设计有一个副作用，就是如果确实想保证一次最多只有一个用户访问一行数据，就得开发人员自己做一些工作

**黑盒和数据库独立性的问题**

要构建一个完全数据库独立的应用，而且是高度可扩展的应用是极其困难的

数据库是不同的。在一个数据库上取得的经验也许可以部分应用于另一个数据库，但是必须有心理准备，二者之间可能存在一些基本差别，可能还有一些细微的差别。

细微的差别（比如对NULL的处理）与基本差别（如并发控制机制）可能有同样显著的影响。

了解数据库，知道它是如何工作的，他的特性如何实现，这是解决这些问题的唯一途径。

## 性能优化

性能调优（目前情况下性能优化至最优）：
（1）根据当前CPU能力、可用内存、I/O子系统等资源情况来设置相应参数
（2）通过索引、物理结构、SQL的优化，具体提高某一个查询的性能

### 性能问题来源

**性能拙劣的罪魁祸首是错误的设计**

### 优化手段

**性能优化要考虑整体**

**使用优化工具**

整体层面的性能优化考虑：

1、CPU 负载高，IO 负载低：内存不够；磁盘性能差（磁盘问题、raid 设计不好、raid 降级）；SQL 的问题；并发锁机制的问题；事务设计问题；大量小数据 IO；大量的全表扫描

2、IO 负载高，CPU 负载低：大量小的 IO 执行写操作；Autocommit，产生大量小 IO；大量大的 IO 执行写操作；SQL 的问题；IO/PS 磁盘限定一个每秒最大 IO 次数

3、IO 和 CPU 负载都高：硬件不够；SQL 存在问题

**SQL 优化的方向**：索引、执行计划、SQL 语句优化、物理分库分表、数据库表结构、整体结构设计

限用Boolean型字段

过于灵活的危险性

约束应明确说明

## 数据库设计原则

### 理解子类型（SubType）

### 历史数据处理

## 架构

### 处理流程

操作模式：异步模式处理（批处理）；同步模式处理（实时交易）

处理数据的方式会影响我们物理结构的设计

### 数据集中化（Centralizing）

分布式数据系统复杂性大大增加

- 远程数据的透明引用访问代价很高
- 不同数据源数据结合极为困难
  - Copy的数据传输开销
  - 无法从数据规划中获益（物理结构，索引）

数据库该如何部署呢：离数据越近，访问速度越快

### 系统复杂性

数据恢复往往是RD和DBA争论焦点

- DBA，即便确保数据库本身工作正常，依然无法了解数据是否正确
- RD，在数据库恢复后进行所有的功能性的检查

## 存储结构

### 内存数据库和磁盘数据库

内存访问比磁盘访问快几个数量级

### 面向行和面向列的数据库

存储结构的选择，到底和什么相关？：和访问相关，不仅仅是需求，同时还有效率。整行存储可以提高空间局部性

对访问整个用户数据有利，不利于某个字段查询

计算聚合性的分析性工具负载（趋势、平均值等）

从同一列中读取多个值可以显著提高缓存利用率和计算效率：向量化指令可以使单条 CPU 指令一次处理多个数据点

具体来说：访问模式、工作负载、计算聚合

### 宽列式存储（BigTable 或 Hbase）

分析的逻辑——存储 - 读取 - 计算（聚合的分析型工作负载）

数据表示为多维映射，列被分组为列族（通常存储相同类型的数据）。在每个列族上，数据被逐行存储。适合存储由一个键或者一组键来检索的数据

### 数据文件和索引文件

数据也是文件存储的，为什么不是文件系统？不依赖于目录和文件的文件系统层次结构来定位数据

- 存储效率（文件已最小化单个存储数据记录开销的方式进行存储）
- 访问效率（用尽可能少的步骤来定位记录）
- 更新效率（记录更新可以以某种特定方式执行，以使磁盘更改次数最小化）

数据文件、索引文件

存储结构基于数据结构

问题在于，数据结构并不描述缓存、恢复、事务性和存储引擎的其他语义

存储结构的三大变量

- 是否使用缓存——B 树节点的内存缓冲区；双组件 LSM 树和 B 树之间不同的缓冲形式
- 可变文件还是不可变文件——同一位置是否可以更新，还是只能附加
- 是否按顺序存储——有序性决定了扫描的范围，是写入优化还是读取优化