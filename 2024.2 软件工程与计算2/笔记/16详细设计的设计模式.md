# 第16章 详细设计的设计模式

## 16.1 设计模式基础

## 16.2 可修改性及其基本实现机制

1. 可修改性包含着几个方面的质量
   - （狭义）可修改性（对已有实现的修改）
   - 可扩展性（对新的实现的扩展）
   - 灵活性（对实现的动态配置）

2. 实现可修改性需要将接口与实现分离
   - 通过接口和实现该接口的类完成接口与实现的分离
   - 通过子类继承父类，将父类的接口和子类的实现相分离
   - 继承关系（A＋B）可能使得灵活性下降，因为父类接口的变化会影响子类，这时可以通过组合关系来解决

利用抽象类机制实现可修改性和可扩展性：只要方法的接口保持不变，方法的实现代码是比较容易修改的，不会产生连锁反应。通过简单修改创建新类的代码，就可以相当容易地做到扩展新的需求（不用修改大量与类方法调用相关的代码。

利用委扦机制实现灵活性：继承的缺陷：一旦一个对象被创建完成，它的类型就无法改变，这使得单纯利用继承机制无法实现灵活性（类型的动态改变）。利用组合（委托）机制可以解决这个问题

## 16.3 策略模式

### 16.3.1 典型问题

### 16.3.2 设计分析

- 首先，可以把上下文和策略分割为不同的类。每个类实现不同的职责，上下文Context类负责满足需求，它除了包含策略信息之外可能还有其他需求职责，而策略类Strategy只负责复杂策略的实现。
- 其次，上下文类和策略类之间的关系用组合比继承更加合适。组合使得：心上下文类和策略类之间的耦合性会很低；策略类的接口和实现的修改都相对比较容易；如果是继承关系，则上下文类只能在行为的n 种实现里面选一种（对象创建时就选定了策略），而如果是组合关系，上下文类则可以维护一个策略队列，实现n 选多，从而达到动态的配置。
- 最后，各种策略则在具体策略类(ConcreteStrategy)中提供，上下文类拥有统一的策略接口。由于策略和上下文独立，策略的增减、策略实现的修改都不会影响上下文和使用上下文的客户。当出现新的促销策略或现有的促销策略发生变化时，只需要实现新的具体策略类（实现策略的接口），由客户使用。

### 16.3.3 解决方案

1. 参与者与协作
2. 应用场景
3. 应用注意点

### 16.3.4 模式实例



## 16.4 抽象工厂模式

### 16.4.1 典型问题

### 16.4.2 设计分析

### 16.4.3 解决方案

![image-20240612162955867](./16详细设计的设计模式/image-20240612162955867.png)

### 16.4.4 模式实例



## 16.5 单件模式

### 16.5.1 典型问题

### 16.5.2 设计分析

### 16.5.3 解决方案

![image-20240612163125728](./16详细设计的设计模式/image-20240612163125728.png)

### 16.5.4 模式实例



## 16.6 迭代器模式

### 16.6.1 典型间题

![image-20240612163212469](./16详细设计的设计模式/image-20240612163212469.png)

