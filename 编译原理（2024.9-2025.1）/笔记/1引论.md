# 1 引论

## 1.1 语言处理器

- 编译器（compiler）：
  - 读入以某一种语言（源语言）编写的程序
  - 输出等价的用另一种语言（目标语言）编写的程序
  - 通常目标程序是可执行的
  - 报告其在翻译过程中发现的源程序中的错误
- 解释器（interpreter）：
  - 直接利用用户提供的输入，执行源程序中指定的操作
  - 不生成目标程序，而是根据源程序的语义直接运行
  - Java 语言的处理结合了编译和解释

**创建一个可执行的目标程序的步骤：**

1. 一个被分割成多个模块的源程序，存放于独立的文件中，由**预处理器**把源程序聚合在一起
   - 源程序还负责将称为宏的缩写形式转换为源语言的语句
2. 经过预处理的源程序作为输入传递给一个**编译器**，编译器产生一个汇编语言程序作为输出
3. 这个汇编语言程序由**汇编器**进行处理，并生成可重定位的机器代码
4. 大型程序经常被分为多个部分进行编译，因此可重定位的机器代码有必要和其他可重定位的目标文件以及库文件连接到一起
   - 一个文件中的代码可能指向另一个文件中的位置，而**链接器**能解决外部内存地址的问题
   - **加载器**把所有可执行目标文件放到内存中执行

## 1.2 一个编译器的结构

编译器可以分为**分析部分**和**综合部分**

1. 分析（analysis）部分 / 前端（front end）
   - 把源程序分解成组成要素，以及相应的语法结构
   - 使用这个结构创建源程序的中间表示
   - 同时收集和源程序相关的信息，存放到**符号表**，符号表和中间表示形式一起传送给综合部分

2. 综合（synthesis）部分 / 后端（back end）
   - 根据中间表示和符号表信息构造目标程序

前端部分是机器无关的，后端部分是机器相关的

编译器可分成顺序执行的一组步骤

<img src="C:\Users\roy-h\AppData\Roaming\Typora\typora-user-images\image-20240705231559223.png" alt="image-20240705231559223" style="zoom:50%;" />

### 1.2.1 词法分析

- 词法分析 / 扫描

  - 读入源程序的字符流，输出为有意义的**词素**
  - 对于每个词素，词法分析器产生**词法单元**（token）作为输出：`<token-name, attribute-value>`
    - `token-name` 由语法分析步骤使用
    - `attribute-value` 指向相应的符号表条目，由语义分析 / 代码生成步骤使用
    - 符号表条目的信息会被语义分析和代码生成步骤使用
  - 词法单元被传送给语法分析

  - 例子：`position = initial + rate * 60` 被转换成 `<id, 1> <=, > <id, 2> <+, > <id, 3> <*, > <number, 4>`

### 1.2.2 语法分析

- 语法分析 / 解析
  - 根据各个词法单元的第一个分量来创建树型的中间表示形式，通常是**语法树**（syntax tree）
  - 该中间表示形式指出了词法单元流的语法结构
  - 树中每个内部结点表示一个运算，该结点的子结点表示该运算的分量
  
  <img src="C:\Users\roy-h\AppData\Roaming\Typora\typora-user-images\image-20240709101548039.png" alt="image-20240709101548039" style="zoom: 50%;" />

### 1.2.3 语义分析

- 使用语法树和符号表中的信息，检查源程序是否满足语言定义的语义约束

- 收集类型信息，用于代码生成、**类型检查**、类型转换
  - 类型检查：
    - 检查每个运算符是否具有匹配的运算分量
    - 自动类型转换

### 1.2.4 中间代码生成

- 在源程序的语法分析和语义分析完成之后，很多编译器生成一个类机器语言的中间表示
  - 两个重要性质：易于生成 + 能被轻松翻译成目标机器上的语言
- **三地址代码**（three-address code）
  - 每个指令最多包含三个运算分量
  - `t1 = inttofloat(60）; t2 = id3 * t1; t3 = id2 + t2;` …
    - 每个三地址赋值指令右部最多只有一个运算符
    - 编译器应生成一个临时名字以存放一个三地址指令计算得到的值
    - 有些三地址指令的运算分量少于三个

<img src="C:\Users\roy-h\AppData\Roaming\Typora\typora-user-images\image-20240709102550916.png" alt="image-20240709102550916" style="zoom:50%;" />

### 1.2.5 代码优化

通过对中间代码的分析，改进中间代码的质量。（更快、更短、能耗更低）

<img src="C:\Users\roy-h\AppData\Roaming\Typora\typora-user-images\image-20240709102800657.png" alt="image-20240709102800657" style="zoom:50%;" />

### 1.2.6 代码生成

- 把中间表示形式映射到目标语言
  - 寄存器的分配
  - 指令选择

<img src="C:\Users\roy-h\AppData\Roaming\Typora\typora-user-images\image-20240709105451195.png" alt="image-20240709105451195" style="zoom:50%;" />

### 1.2.7 符号表管理

记录源程序中使用的变量的名字，收集各种属性

### 1.2.8 将多个步骤组合成趟

每趟读入一个输入文件，产生一个输出文件

“步骤”（phase）是逻辑组织方式

“趟”和具体的实现相关

### 1.2.9 编译器构造工具

扫描器（Lex）、语法分析器（Yacc）、语法制导的翻译引擎、…

## 1.3 程序设计语言的发展历程

**强制式**语言 / **声明式**语言：前者指明如何完成，后者指明要完成哪些计算

## 1.4 构建一个编译器的相关科系

## 1.5 编译技术的应用

### 1.5.1 高级程序设计语言的实现

- 程序设计语言的新发展向编译器设计者提出新的要求
  - 设计相应的算法和表示方法来翻译和支持新的语言特征，如多态、动态绑定、类、类属（模板）、…

### 1.5.2 针对计算机体系结构的优化

通过降低高级语言的执行开销，推动这些高级语言的使用

并行性、内存层次结构

### 1.5.3 新计算机体系结构的设计

- 编译器设计者还需要更好地利用新硬件的能力
  - RISC技术、多核技术、大规模并行技术

### 1.5.4 程序翻译

二进制翻译 / 硬件合成 / 数据查询解释器 / 编译后模拟

### 1.5.5 软件生产率工具

类型检查

边界检查（软件测试）

内存管理工具（内存泄漏）

电子设计自动化（EDA）静态分析

## 1.6 程序设计语言基础

- 静态 / 动态
  - 静态：支持编译器静态决定某个问题
  - 动态：只允许在程序运行时刻作出决定
- 作用域
  - x的作用域指程序文本的一个区域，其中对x的使用都指向这个声明
  - **静态作用域**（static scope）：通过静态阅读程序可决定
  - **动态作用域**（dynamic scope）：运行时确定x的指向

- 环境与状态
  - 环境（environment）：是从名字到存储位置的映射
  - 状态（state）：从存储位置到它们值的映射

- 静态作用域和块结构：
  - C语言使用静态作用域
    - C语言程序由顶层的变量、函数声明组成
    - 函数内部可以声明变量 (局部变量/参数)，这些声明的作用域在它出现的函数内
    - 一个顶层声明的作用域包括其后的所有程序
  - 作用域规则基于程序结构，声明的作用域由它在程序中的位置决定
  - 也通过public、private、protected进行明确控制
