# 10. 调度

1. 调度：为了满足既定目标，对计算任务进行资源分配的行为

2. 调度指标：
   - CPU 利用率
   - 公平： 同等优先级下的进程获得的CPU使用时间应该尽可能相等
   - 吞吐量：单位时间内完成执行的进程数
   - 周转时间：某个进程需要完成的时间
   - 等待时间：某个进程在就绪队列的时间
     - 等待时间 = 周转时间 - 获得CPU执行的时间
   - 响应时间：从发出申请执行到第一次获得响应执行的时间

3. 调度的时机
   - 发生系统调用
   - 某个运行的进程阻塞了
   - 发生中断

**机制与策略**

1. 定义：
   1. **机制（Mechanism）**：描述系统“怎么做”。机制提供了执行策略所需的具体方法和工具。例如，调度算法的机制可能包括保存和恢复进程的状态、管理进程队列等。
   2. **策略（Policy）**：描述系统“可以做什么”。策略决定了在特定情境下应该采取什么行动。例如，在调度算法中，策略可能规定应该选择哪个进程来执行。

2. 机制与策略分离的优势

   - **模块化设计**：通过分离机制与策略，可以将系统设计成多个模块，每个模块负责不同的功能。这种模块化设计可以减少系统的复杂度，使得每个模块的开发、测试和维护变得更加容易。

     **灵活性**：当机制与策略分离时，可以在不修改底层机制的情况下更改系统的策略。这使得系统能够更容易地适应新的需求或优化现有功能。

     **可维护性**：由于机制与策略是分离的，更改策略不会影响底层机制，从而减少了修改系统时可能引入的错误和不一致性。

调度策略：批处理任务的调度、交互性任务的调度、实时任务的调度

## 10.1 批处理任务的调度

### 10.1.1 先来先服务（First Come First Serve, FCFS）

- **描述**：按照任务到达系统（就绪）的先后顺序进行调度，也叫先进先出（First In First Out, FIFO）。
- **优点**：实现简单，每个任务按顺序执行。
- **缺点**：存在护航效应（convoy effect），即短运行时间的进程排在长运行时间的后面，导致平均等待时间过长。
- **示例**：
  - 任务P1、P2、P3的到达和执行时间如下：
    - P1：24ms
    - P2：3ms
    - P3：3ms
  - 调度顺序为P1 -> P2 -> P3，等待时间分别为P1: 0ms, P2: 24ms, P3: 27ms，平均等待时间为17ms。

### 10.1.2 最短任务优先（Shortest Job First, SJF）

- **描述**：将每个任务与其需要运行的时间关联，运行时间最短的优先被调度。
- **优点**：平均等待时间较短。
- **缺点**：需要提前知道每个任务的运行时间；可能导致长任务饥饿。
- **示例**：
  - 任务P1、P2、P3、P4的运行时间如下：
    - P1：6ms
    - P2：8ms
    - P3：7ms
    - P4：3ms
  - 调度顺序为P4 -> P1 -> P3 -> P2，等待时间分别为P4: 0ms, P1: 3ms, P3: 9ms, P2: 16ms，平均等待时间为7ms。

**证明：就平均等待时间而言，SJF是最优的**

1. **给定条件**：
   - 有 $ N $ 个进程。
   - 进程 $ k $ 的执行时间为 $ t_k $。
   - 进程 $ k $ 的等待时间为 $ W_k $。

2. **计算平均等待时间**：
   - 任意调度顺序 $ S $ 的平均等待时间为：
     $$
     W_S = \frac{W_1 + W_2 + \ldots + W_N}{N}
     $$
   - 其中 $ W_k = W_{k-1} + t_{k-1} $（假设第一个进程的等待时间为 0）。

3. **排序过程**：
   - 对于任意的进程序列 $ S = (1, 2, 3, \ldots, N) $，我们可以使用冒泡排序（Bubble Sort）将序列按照执行时间升序排列。
   - 如果前一个进程的执行时间大于后一个进程的执行时间，交换相邻的两个进程。

4. **证明步骤**：
   - 初始状态下的平均等待时间计算公式为：
     $$
     W_S = \frac{(N-1)t_1 + (N-2)t_2 + \ldots + t_{N-1}}{N}
     $$
   - 通过交换两个相邻进程 $ k-1 $ 和 $ k $（若 $ t_{k-1} > t_k $），新的序列的平均等待时间为：
     $$
     W_S' = \frac{(N-1)t_1 + \ldots + (N-(k-1))t_k + (N-k)t_{k-1} + \ldots + t_{N-1}}{N}
     $$
   - 两者相减可得：
     $$
     W_S - W_S' = (N-(k-1))t_{k-1} + (N-k)t_k - (N-(k-1))t_k - (N-k)t_{k-1} = t_{k-1} - t_k
     $$
     由于 $ t_{k-1} > t_k $，所以 $ W_S > W_S' $，每次交换都会减少平均等待时间。

5. **得出结论**：
   - 经过多次交换后，最终得到的序列即为执行时间升序排列的序列（即 SJF 顺序）。
   - 因此，SJF 调度策略在所有可能的调度策略中，使得平均等待时间最小化

### 10.1.3 最短剩余时间优先（Shortest Remaining Time First, SRTF）

1. **非抢占式**调度算法：选择一个进程来运行，然后就让它一直运行，直到它被阻塞（无论是在I/O操作上还是等待另一个进程），或者自愿释放CPU

2. **抢占式**调度算法：选择一个进程，并允许其运行一段固定的最长时间。如果在时间间隔结束时它仍在运行，则被挂起，调度器选择另一个进程来运行

3. 最短剩余时间优先（SRTF）是 SJF 的抢占式版本

   - **抢占式**：不同于非抢占式调度算法（如SJF），SRTF允许在新的进程到达时中断当前进程的执行。

   - **选择最短剩余时间**：始终选择剩余执行时间最短的进程运行。


假设有以下进程：

| 进程 | 到达时间（ms） | 执行时间（ms） |
| ---- | -------------- | -------------- |
| P1   | 0              | 8              |
| P2   | 1              | 4              |
| P3   | 2              | 9              |
| P4   | 3              | 5              |

调度过程如下：

1. **0 ms**：只有P1到达，P1开始执行。
2. **1 ms**：P2到达，剩余时间为4，小于P1的7（8-1），因此P2抢占P1开始执行。
3. **2 ms**：P3到达，但P2剩余时间为3（4-1），仍然小于P3的9，因此继续执行P2。
4. **3 ms**：P4到达，P4的执行时间为5，大于P2的剩余时间2（4-2），继续执行P2。
5. **5 ms**：P2执行完毕，P1的剩余时间为7，P3和P4分别为9和5，选择P4执行。
6. **10 ms**：P4执行完毕，剩余的P1和P3分别为7和9，选择P1执行。
7. **17 ms**：P1执行完毕，选择P3执行，直至完成。

平均等待时间：[(10 − 1) + (1 − 1) + (5 − 3) + (17 − 2)]/4 = 6.5ms

优点

- **优化平均等待时间**：由于总是选择剩余时间最短的进程，SRTF通常能有效地优化平均等待时间。
- **动态响应新进程**：能实时响应新进程的到达并进行调度调整，适应性强。

缺点

- **需要预知执行时间**：必须提前知道每个进程的执行时间或能动态预测，这在实际应用中较难实现。
- **可能导致长进程饥饿**：如果不断有新短进程到达，长进程可能一直得不到执行机会，导致饥饿现象。

**时间预测算法（Exponential Moving Average）**

1. 时间预测算法的核心思想是：**下一个运行时间应该与之前一次类似**。这是一种基于历史数据的预测方法，用于估计进程的未来运行时间。

2. 公式的定义如下：

   - $ t_n $ 是第 $ n $ 次的实际运行时间。

   - $ \tau_{n+1} $ 是预测的下一次（第 $ n+1 $ 次）的执行时间。

   - $ \alpha $ 是相关系数，介于0到1之间。

   预测公式为：$ \tau_{n+1} = \alpha t_n + (1 - \alpha) \tau_n $

   将公式展开：

   $ \tau_{n+1} = \alpha t_n + (1 - \alpha) \alpha t_{n-1} + (1 - \alpha)^2 \alpha t_{n-2} + \ldots + (1 - \alpha)^j \alpha t_{n-j} + \ldots + (1 - \alpha)^{n+1} \tau_0 $

   由于 $ \alpha $ 和 $ 1 - \alpha $ 都小于等于1，因此该多项式中每一项的权重会逐渐减小。这意味着最近的执行时间对当前的预测影响更大，而更早之前的执行时间影响较小。

   两个极限情况：

   1. 当 $ \alpha = 0 $ 时：$ \tau_{n+1} = \tau_n = \tau_{n-1} = \ldots = \tau_0 $​，这意味着最近的执行历史没有关联，所有预测值都等于初始值

   1. 当 $ \alpha = 1 $ 时：$ \tau_{n+1} = t_n $，这意味着预测值仅与最近的执行时间相关。


​	一般而言，$ \alpha $ 通常取值为0.5。

## 10.2 交互性任务的调度

1. 计算密集型（CPU bound）和 I/O 密集型（I/O bound）

   - CPU 密集型：主要消耗CPU计算资源，会在 CPU 上执行大部分时间的计算和逻辑判断等操作，而不需要等待外部资源（如磁盘读写或网络通信）完成
   - I/O 密集型：系统大部分的时间在等待 I/O（硬盘/内存/键盘）的读取/写入操作（即和外界进行频繁交互的进程），此时 CPU 负载并不高，需要消耗CPU计算的时间很少

2. **时间片轮转调度（Round-Robin, RR）**

   - **固定时间片**：每个进程被分配一个固定的时间片（time slice），一般在10ms到100ms之间。如果一个进程在时间片内没有完成，就会被抢占，切换到下一个进程。

     **公平性**：所有进程按轮流顺序执行，确保每个进程都能公平地获得CPU时间。

     **响应时间**：由于进程定期被调度执行，所以交互性任务的响应时间较短。

   - **缺点**：

     - 平均周转时间较长，并且有较高的overhead
     - 在运行既有 I/O 密集型任务又有计算密集型任务的情况下，当 I/O 密集型任务执行 I/O 操作时，它会让出处理器，这时即使 I/O 操作很快完成，也必须等待重新分配处理器，直到其他计算密集型任务用完他们完整的CPU切片

3. **优先级调度**：每个进程被赋予一个优先级数值，系统总是选择优先级最高的进程进行调度。优先级可以是静态的（在进程创建时确定并不再改变）或动态的（在进程执行过程中可以改变）。

   - 优先级调度的问题：饿死（Starvation）
   - 解决方案：老化（Aging）：随着时间的推移，进程的优先级逐渐增加，从而确保所有进程最终都能得到执行机会。动态改变优先级的策略，如：多级反馈队列

4. **多级反馈队列（Multilevel Feedback Queue, MFQ）**

   - 一个进程可以在各个队列（代表不同优先级）之间移动

   - **多个优先级队列**：每个队列有不同的优先级和时间片长度。

     **动态调整优先级**：进程可以在不同优先级的队列间移动，根据其CPU使用情况动态调整。

     **公平性和响应性**：高优先级队列时间片短，适合I/O密集型进程，低优先级队列时间片长，适合CPU密集型进程。

   - CPU密集型进程将下沉到长时间片的优先级队列

     I/O 密集型进程将保持在高优先级队列中

   - **可能存在饥饿问题**：低优先级队列中的CPU密集型进程可能永远无法被调度，需引入老化机制来解决。

## 10.3 实时任务的调度



## 10.4 真实操作系统调度器



## 10.5 调度的一些其他问题

**优先级反转问题**：在系统中高优先级任务被低优先级任务阻塞的现象。通常发生在多任务系统中，尤其是在任务需要访问共享资源（如锁）时。

**具体过程**：

1. 系统中有三个任务T1（低优先级）、T2（中优先级）、T3（高优先级）。
2. T1首先运行，并获得了一个锁，进入临界区。
3. T3开始运行，由于其优先级高于T1，T3抢占了T1的运行。
4. T3试图获取锁，但被阻塞
5. T2开始运行，因为它的优先级高于T1，所以它将运行
6. T3的优先级高于T2，但由于T2正在运行，T3被阻塞在等待T1上，而现在T1可能永远不会运行

优先权极限：每当一个任务获取一个锁时，该任务的优先级被提升到与该锁关联的优先级上限相同的优先级

优先级继承：当一个任务持有一个锁时，如果其他（更高优先级的）任务试图获取该锁，那么持有锁的任务的优先级将被提升到那个更高优先级的任务的优先级