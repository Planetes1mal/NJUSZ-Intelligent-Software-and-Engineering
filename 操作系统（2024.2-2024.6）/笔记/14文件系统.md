# 14. 文件系统

1、文件系统：对持久性存储的抽象和接口

- **持久性和命名数据**：文件和目录
  - 存储在系统中直到显式删除为止
  - 可以通过文件系统关联的可读标识符访问
- **访问和保护**：提供打开、读取、写入和其他操作；调节不同用户对文件的访问。
- **磁盘管理**：公平有效地利用磁盘空间
  - 分配空间给文件，并跟踪空闲空间
  - 快速访问文件
- **可靠性**：不得丢失文件数据

2、文件
文件命名
文件类型

文件元数据（属性）： inode 文件控制块

3、文件访问
4、文件应用级接口（系统调用）
5、文件描述符
6、文件偏移

7、打开文件表

inode表（系统范围）：为每个inode点创建一个条目

8、目录（Directory）

9、共享文件

软链接和硬链接是文件系统中的两种不同类型的链接，主要用于创建文件的多个引用。下面是详细解释：

### 硬链接（Hard Link）

- **定义**：在目录中创建另一个名称，并将其指向原始文件的相同 inode 号。
- **特点**：
  - 文件没有被复制，只是有两个名称（两个绝对路径）都指向同一个文件。
  - 硬链接本质上是 inode 号的别名。
  - 每个 inode 有一个引用计数（链接计数器），删除链接时，引用计数减一；如果计数达到 0，目标文件将被删除。
  - 硬链接不能链接到另一个文件系统上的文件，因为 inode 号只在一个文件系统内是唯一的。
  - 不允许链接到目录，这防止了在目录层次结构中创建循环，避免了父目录的不明确性（例如，如果多个父目录有指向同一子目录的链接，那么该目录中的 “..” 指向什么？）。

### 软链接（Soft or Symbolic Link）

- **定义**：创建一种不同类型的文件（链接类型），它包含目标文件路径的别名。
- **特点**：
  - 软链接可以链接到目录，或跨文件系统链接。
  - 当需要解析路径名时，符号链接被解析，找到目标文件的名称，并使用新名称打开。
  - 目标可以是另一个符号链接（递归解析）。
  - 比硬链接效率低。
  - 当删除符号链接时，目标文件保持不变；当目标文件被删除时，会产生引用悬空（dangling reference），即该链接指向一个已不存在的路径名。

### 多级索引

多级索引是为了解决大文件的数据块管理问题而设计的一种文件系统索引方法。它通过间接指针将索引块中的指针指向另一个由指针组成的数据块，每个指针再指向实际的数据块。这种结构使得索引具有更高的灵活性和可扩展性。

#### 特点

- **间接指针**：可以将索引块中的指针指向一个由指针组成的数据块，这些指针再指向实际的数据块。
- **索引块结构**：一个索引块中可以包含固定数量的直接指针（指向数据块）和固定数量的间接指针。
- **树状结构**：索引的结构形成一个非平衡树，适用于大小不同的文件。
- **支持不同文件大小**：多级索引对于小文件和大文件都能很好地支持。
- **常见级数**：一般有2级和3级的间接指针。

#### 实例说明

假设数据块大小为4KB，一个表项为4字节，一个索引块包含15个指针。

- **前12个指针**：直接指向数据块（12 * 4KB = 48KB）。
- **第13个指针**：指向单级间接数据块（4KB * 1024 = 4MB）。
- **第14个指针**：指向双级间接数据块（4MB * 1024 = 4GB）。
- **第15个指针**：指向三级间接数据块（4GB * 1024 = 4TB）。

#### 多级索引示例

1. 直接指：前12个指针直接指向12个数据块，每个数据块4KB，总共48KB。
2. 单级间接指针：第13个指针指向一个间接块，间接块包含指向数据块的指针。总共可以索引4MB的数据。
3. 双级间接指针：第14个指针指向一个双级间接块，该块包含指向单级间接块的指针。总共可以索引4GB的数据。
4. 三级间接指针：第15个指针指向一个三级间接块，该块包含指向双级间接块的指针。总共可以索引4TB的数据。

#### 优点

- **灵活性**：可以支持非常大的文件，同时不会浪费空间。
- **扩展性**：文件大小增加时，可以通过增加间接指针层次来管理更多的数据块。
- **效率**：对于小文件，可以直接使用直接指针，对于大文件，间接指针提供了灵活的扩展性。

#### 缺点

- **复杂性**：多级索引结构较为复杂，管理和实现上需要更多的逻辑。
- **性能开销**：访问深层次的间接指针需要更多的访问操作，可能会影响性能。

## 日志

用于文件系统的数据保护机制，其主要目的是确保文件系统的一致性和可靠性，尤其是在系统崩溃或电源故障时

#### 基本概念

- **事务（Transaction）**：文件系统的更新操作被当作一个事务进行管理。事务包含所有需要一起提交到磁盘的操作。
- **预写日志（Write-ahead Logging）**：在覆盖结构之前，先写一个小日志（存储在磁盘上），描述将要做的事情。这一思路借鉴自数据库系统。

#### 日志结构

日志文件系统通过记录事务的开始和结束来管理文件更新：

1. **事务开始（Transaction Begin, TxB）**：记录事务的开始，包括事务标识符和其他相关信息。
2. **待处理更新**：将 inode、位图和数据块的具体更新写入日志。
3. **事务结束（Transaction End, TxE）**：记录事务的结束。

#### 日志的工作流程

1. **写入日志**：
   - 将 inode、位图和数据块的更新写入日志。
   - 等待所有这些写入操作完成。
   - 写入 TxE 块，将日志标记为安全状态。
2. **更新磁盘**：
   - 将 inode、位图和数据块写入它们的最终磁盘位置（检查点）。
   - 释放已被检查点记录的事务占用的日志空间。

#### 崩溃恢复

当需要从崩溃中恢复时，文件系统会扫描日志并查找已提交到磁盘的事务：

- **在日志提交之前崩溃**：忽略待处理的更新。
- **在日志提交之后但在检查点之前崩溃**：按顺序重放已提交的事务（重做日志）。尽管可能会有写冗余，但这种情况并不频繁。

#### 有限日志（Bounded Log）

日志被视为循环数据结构（bounded buffer），反复重用。一旦事务被检查点记录，释放它在日志中占用的空间。用一个日志超级块记录哪些事务尚未被检查点记录。

#### 元数据和数据日志记录

- 元数据日志记录：
  - 用户数据不写入日志（更常见）。
  - 先记录元数据日志，然后写入数据块。这确保一致性，但文件可能包含垃圾数据。
  - 更好的做法是先写入数据块，然后记录元数据日志，确保指针不会指向垃圾数据。
- 数据日志记录：数据被写入两次（到日志和实际数据块），代价较高。