[TOC]

# 1. 概述

## 1.1 什么是操作系统？

硬件、软件、操作系统（管理硬件和软件的软件）

操作系统的功能：
（1）提供简洁、易用的物理层抽象
（2）资源的管理
（3）优化性能

## 1.2 操作系统历史



# 2. 各种视角下的操作系统

## 2.1 应用视角下的操作系统

### 2.1.1 什么是程序

```c
#include <stdio.h>
int main()
{
    printf("Hello World\n");
}
```

操作系统上的程序：所有的指令都只能计算

解决异常退出：交给操作系统

Hello, World 的汇编实现

```asm
#include <sys/syscall.h>
.globl _start
_start:
 movq $SYS_write, %rax // write(
 movq $1, %rdi // fd=1,
 movq $st, %rsi // buf=st,
 movq $(ed - st), %rdx // count=ed-st
 syscall // );
 movq $SYS_exit, %rax // exit(
 movq $1, %rdi // status=1
 syscall // );
st:
 .ascii "\033[01;31mHello, OS World\033[0m\n"
ed:
```

### 2.1.2 状态机

程序就是状态机

- 状态 = M（内存）+ E（寄存器）

- 初始状态 = 程序启动时操作系统给安排的状态
- 状态转移 = 执行一条指令

程序的状态机模型：

![image-20240524101316027](./1-2绪论/image-20240524101316027.png)

理解高级语言程序：

C 程序的状态机模型

- 状态 = 堆 + 栈 + 全局变量

  - 初始状态 = 仅有⼀个 frame `main(argc, argv);` 全局变量为初始值

  - 迁移 = 执⾏⼀条简单语句

    - 执⾏当前调⽤栈栈顶的那个栈指针(frames.top.PC处)的简单语句

    - 如果是函数调⽤的话，本质上就是压⼊⼀个新的栈帧(stack frame), 并设置这个新的frame.PC = 所调⽤函数的⼊⼝

    - 函数返回 = pop frame

两种状态机：

- 汇编指令序列.s：状态是（M, R）；执行指令进行状态迁移
- 高级语言代码.c：状态是栈、全局变量；状态迁移是执⾏语句
- 编译器即为二者的桥梁，不同的优化级别可以产生不同的指令序列

### 2.1.3 操作系统上的软件（应用程序）

- 操作系统中的任何程序本质上为包含 syscall 的状态机

- 操作系统管理着所有的硬件 / 软件资源

  只能用操作系统允许的方式访问操作系统中的对象

（⼆进制）程序也是操作系统中的对象

- 可执行文件

### 2.1.4 打开程序的执行：Trace (追踪）

- System call trace
- 允许我们观测状态机的执⾏过程
- 所有进程都在“操作系统”的监控之下
- 操作系统为进程提供了ptrace系统调⽤，其可以帮助⼀个进程去查看另外⼀个进程，甚⾄是修改另外进程的运行时的寄存器，以至于植⼊代码

### 2.1.5 操作系统中“任何程序” 的一生

1. 初始状态：执行execve加载到内存，设置初始状态
2. 状态机执行：
   - 进程管理
   - 文件 / 设备管理
   - 存储管理
   - 调用 exit 等退出

- 所有的这些程序都是在操作系统 API (syscall) 和操作系统中的对象上构建。**本质都是调⽤ syscall 的状态机**

## 2.2 硬件视角下的操作系统

### 2.2.1 数字电路与状态机

- 状态 = 寄存器保存的值（flip-flop）

- 初始状态 = REST
- 迁移 = 组合逻辑电路 (NAND, NOT,  AND, OR, NOR…) 计算寄存器下⼀ 时钟周期的值

### 2.2.2 计算机硬件的状态机模型

- 状态：内存和寄存器数值
- 初始状态： CPU Reset
- 状态迁移：
  - 任意选择一个处理器 CPU
  - 响应处理器外部中断
  - 从 CPU 的 PC 取指令执行

- 硬件与程序员的约定：为了让 “操作系统” 这个程序能够正确启动
  - Reset 的状态
  - Reset 后执行的程序应该做什么

### 2.2.3 Firmware 标准

- BIOS：Legacy BIOS
  - BIOS 提供机制，将程序员的代码载入内存
    - Legacy BIOS 把第⼀个可引导设备的**第⼀个 512 字节**（MBR）加载到物理内存的 7c00 位置
    - 此时处理器处于 16-bit 模式
    - 规定 CS:IP = 0x7c00
- UEFI
  - 传统BIOS只能⽀持有限的硬件，许多设备都需要 “驱动程序” 才能访问
  - UEFI 上的操作系统加载
    - 磁盘必须按 GPT (GUID Partition Table) ⽅式格式化
    - 预留⼀个 FAT32 分区 (可以⽤命令lsblk/fdisk 查看)
    - Firmware 能够加载任意⼤⼩的 PE 可执⾏⽂件.efi
      - EFI 应⽤可以再次返回 firmware

### 2.2.4 CPU Reset 之后的世界

- 模拟⽅案：QEMU

  - QEMU模拟硬件系统，在模拟的硬件之上再加载操作系统，那么宿主机（运⾏QEMU的机器）即可观察这⼀切

  - QEMU配合GDB

    ```bash
    qemu-system-x86_64 -s -S mbr.img
    ```

    ```bash
    gdb
    target remote localhost:1234
    ```

    - CPU Reset之后的PC指向的地址0xfff0
    - MBR的第⼀条指令被加载到0x7c00
    - 利⽤GDB的watch point可以看到是谁把MBR加载到内存的之处

  - MBR里的程序叫做bootloader(加载器)
    - 在真实环境中，MBR会加载⼆级bootloader而不是操作系统，比如对于Linux⽽⾔，bootloader程序GRUB就是两阶段的
      - 先执⾏GRUB在MBR⾥512字节⾥的程序，然后再从磁盘加载剩余的程序到内存，并执行这个⼆级bootloader，最后由这个⼆级bootloader加载磁盘中的操作系统内核到内存中
    - 加载器的工作细节
      - 假设 MBR 包含的是⼀级bootloader，做完⼀些必要的处理器初始设置之后
        - 将16-bit → 32-bit模式
        - 跳转到 ELF32/64 的加载器
          - 按照约定的磁盘镜像格式加载操作系统内核 （⼀个编译完成的ELF⽂件）

### 2.2.5 具体例子：实现最小“操作系统”

- Abstract Mechine
- 两种执行流
  - 普通控制流
  - 异常控制流：遇到中断、异常、⾃陷指令时，CPU会转移到另外的指令流入口
    - 异步时间处理

- 上下文切换
  - 进入另外入口前，CPU 需要保护现场，即当前CPU的⼀些寄存器的值（上下文）
    - PC 寄存器（CS、IP）、栈指针（SP、SS）、控制寄存器、 virtual address translation⼊⼝寄存器、其他⼀些数据寄存器
    - 这个“现场”将会保存在内核栈中（安全可靠！），等异常控制流处理完毕时，并再次调度这个执行流时，这个“现场”将会被弹出到CPU上，恢复之前的执⾏

## 2.3 抽象视角下的操作系统

- 操作系统本身就是状态机

  - 内部状态为用户进程的元信息、内核栈、内核堆、操作系统代码区
  - 操作系统在硬件加载完毕和初始化之后就变成了就成为了 interrupt/trap/fault handler

  - 操作系统的状态是被动迁移的，用户程序执行syscall才会改变操作系统状态、硬件中断事件发⽣后（如时钟中断）才会改变操作系统状态
