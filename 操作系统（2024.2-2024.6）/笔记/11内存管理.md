# 11. 内存管理

1、物理内存：存储介质

2、保护：违背规约、非法操作

- 修改别的状态机的状态
- 增加状态机的大小时，占用的额外空间还处于“有用”状态
- 不遵守状态机的内部状态的读、写权限

### 11.1 虚拟内存

虚拟内存是内存管理的重要抽象，它允许程序运行时使用虚拟地址而非物理地址。这种抽象提供了以下几个关键特性：

1. **虚拟地址空间**：每个应用程序有独立的虚拟地址空间，使其看起来像是独占整个内存。这增强了进程之间的隔离和保护。
2. **地址翻译**：虚拟地址由硬件（通常是**MMU**，Memory Management Unit）自动转换为物理地址。这个过程对应用程序是透明的，应用程序无需关心物理内存的位置和管理。

#### 地址翻译（Address Translation）

地址翻译是虚拟内存管理的核心过程。其基本思想是将虚拟地址映射到物理地址。具体过程如下：

1. **地址翻译函数**：地址翻译可以视作一个函数，它将进程ID（pid）和虚拟地址映射到物理地址。
   $$
   \text{physical address} = f(\text{pid}, \text{virtual address})
   $$

2. **MMU和地址翻译**：地址翻译由MMU执行。虚拟地址空间由操作系统配置，并启用虚拟内存机制。每个应用程序使用虚拟地址访问内存，MMU将其自动翻译为物理地址。

3. **保护**：不同进程的地址映射互不相交，这样可以防止进程之间的内存访问干扰。

4. **动态重定位**：进程在运行时可以被映射到不同的物理地址，而不需要重新编译。这种机制被称为动态重定位。

5. **数据共享**：不同的进程可以通过映射不同的虚拟地址到相同的物理地址来共享数据。

6. **连续空间假象**：虚拟地址空间中的连续地址可以映射到物理内存中的不连续区域，从而提供编程的方便性。

#### 地址翻译机制中的关键组件

1、**页表**：存储虚拟地址到物理地址的映射关系。

2、**TLB（Translation Lookaside Buffer）**：缓存最近使用的地址翻译结果，提高地址翻译速度。

3、**页表项（PTE, Page Table Entry）**：包含物理页号、保护位、有效位等信息，用于控制地址翻译和访问权限。

## 11.2 连续内存分配



## 11.3 分段（Segment）



## 11.4 分页（Paging）

### 基本概念

1. **页（Page）和帧（Frame）**：
   - **虚拟页（Virtual Page, VP）**：虚拟内存被划分成固定大小的块，称为页。
   - **物理帧（Physical Frame, PF）**：物理内存也被划分成同样大小的块，称为帧。
   - 任意虚拟页可以映射到任意物理页
2. **页表（Page Table）**：
   - 每个进程有一个页表，用于记录虚拟页到物理帧的映射关系。
   - 页表项（Page Table Entry, PTE）包含物理页号（Physical Page Number, PPN）及其他控制信息：
     - 有效位（Valid bit）：转换是否有效（支持稀疏空间）
     - 存在位（Present bit）：页面是否实际存储在内存中
     - 保护位（Protection bits）：页面是否可以被读取、写入或执行
     - 引用位（Reference bit）：页面是否已被访问
     - 脏（修改）位（Dirty/modified bit）：页面自被载入内存以来是否已被修改
   - **页表基址寄存器（PTBR, Page Table Base Register）**：
     - 存储页表的起始地址。
     - CPU在进行地址转换时，通过PTBR找到页表。
   - **共享**：
     - 通过将多个进程的虚拟页映射到相同的物理帧，可以实现进程间的内存共享。
     - 例如，共享代码段或数据段。
   - **保护**：
     - 通过在页表项中设置保护位，可以控制页的访问权限（如读、写、执行）。
     - 这样可以防止进程非法访问其他进程的内存。
3. **碎片问题**
   1. **内部碎片（Internal Fragmentation）**：
      - 由于页的大小固定，当分配的内存不足一页时，会产生内部碎片。
      - 内部碎片是指页内未被使用的部分。

   2. **外部碎片（External Fragmentation）**：分页机制没有外部碎片，因为页和帧的大小固定，且任意虚拟页可以映射到任意物理帧。

### 地址转换过程

虚拟地址通常由两个部分组成：
- **虚拟页号（Virtual Page Number, VPN）**：表示虚拟页。
- **页内偏移（Offset）**：表示页内的具体位置。

物理地址由物理页号（Physical Frame Number, PFN）和页内偏移组成。

地址转换过程如下：
1. 从虚拟地址中提取虚拟页号和页内偏移。
2. 在页表中查找虚拟页号对应的物理帧号。
3. 组合物理帧号和页内偏移，得到物理地址。

### 页表结构

1. **单级页表（Single-level Page Table）**：
   - 页表是一个线性数组，每个数组元素是一个页表项。
   - 优点：结构简单，容易实现。
   - 缺点：对于大地址空间，页表会非常大，占用大量内存。

2. **多级页表（Multi-level Page Table）**：
   - 将页表分为多个层级，每级页表是一个页表页。
   - 顶层页表存储指向下一级页表的指针，以此类推，直到底层页表存储实际的物理帧号。
   - 优点：可以减少页表占用的内存，支持稀疏地址空间。
   - 缺点：地址转换需要多次内存访问，增加了时间开销。

3. **倒排页表（Inverted Page Table）**：
   - 采用一个全局页表，每个物理帧对应一个页表项。
   - 每个页表项包含使用该物理帧的进程ID和虚拟页号。
   - 优点：节省内存，适用于大地址空间。
   - 缺点：查找速度慢，需要使用哈希表加速查找。

### 页表优化

1. **TLB（Translation Lookaside Buffer）**：
   - TLB是一种高速缓存，用于存储最近使用的页表项。
   - 当地址转换时，首先在TLB中查找，如果命中，则直接使用TLB中的结果；如果未命中，则访问页表，并将结果加载到TLB中。
   - TLB提高了地址转换的速度，但需要处理TLB未命中的情况。

2. **页表页（Page Table Page）**：
   - 页表存储在物理内存中，每个页表页包含多个页表项。
   - 多级页表中的每级页表页占用一个物理帧。

## 11.5 TLB

### TLB 的基本概念

1. **TLB 的作用**：
   - 由于每次地址转换都需要访问页表，而访问内存速度较慢，因此通过缓存最近使用的页表项来加速地址转换。
   - 当CPU需要转换虚拟地址时，首先在TLB中查找，如果找到对应的物理地址（称为TLB命中），则直接应用转换（fast path），否则，如果TLB未命中，则在页表中查找映射（页表遍历），并更新TLB（slow path）

2. **一个典型的TLB缓存的项包括**：
   - 页号及其对应的帧号
   - 有效位：条目是否有有效的转换
   - 保护位：页面的访问方式
   - 脏（修改）位：页面是否已被修改

### TLB的性能优化

#### 局部性原理（Principle of Locality）

- 利用指令和数据引用的局部性

  - 时间局部性：某个数据被访问后，不久的将来可能会再次被访问。

  - 空间局部性：某个数据被访问后，其邻近的数据也可能会被访问。

- TLB的大小一般在64到1024个条目之间，具体大小取决于硬件实现。

  - 存储最可能被多的选中的地址翻译才能高效发挥TLB的作用

  - 支持某些条目可以固定下来以便永久快速访问

#### 有效访问时间（EAT, Effective Access Time）

- EAT是衡量TLB性能的指标，计算公式为：
  $$
  \text{EAT} = (\epsilon + t)\alpha + (\epsilon + 2t) (1 - \alpha)
  $$
  其中：

  - $\epsilon$：TLB查找时间。
  - $t$：内存访问时间。
  - $\alpha$​：TLB命中率：在TLB中找到页号的百分比

#### 处理TLB Miss

##### TLB的替换策略

当TLB已满且发生TLB未命中时，需要替换某个TLB条目。常见的替换策略包括：
- 先进先出（FIFO）：最早进入TLB的条目最先被替换。
- 最近最少使用（LRU）：最近最少被使用的条目最先被替换。
- 随机替换：随机选择一个条目进行替换。

##### 谁来处理TLB miss？

1、**硬件处理TLB未命中（如x86架构）**：

- 当TLB未命中时，硬件自动进行页表查找，将结果加载到TLB。
- 优点：处理迅速，对操作系统透明。

2、**软件处理TLB未命中（如MIPS架构）**：

- 当TLB未命中时，硬件引发异常，操作系统处理TLB未命中。
- 优点：灵活性高，可以实现复杂的替换策略。

#### TLB一致性

在上下文切换时，TLB中的条目可能失效，需要保证TLB的一致性：
- 清空TLB：上下文切换时清空TLB中的所有条目。
- 带标记的TLB：每个TLB条目带有一个地址空间标识符（ASID），区分不同进程的地址空间。

## 11.6 缺页异常

当程序引用其地址空间的一部分时：

- 如果页面在物理内存中，则直接进行地址转换
- 如果不在，则发生**缺页异常（Page Fault）**，操作系统被调用来处理该异常：检测并将页面加载到内存中，然后重新执行指令（引用该地址空间的指令）

### 具体流程

1、硬件陷入内核，进行Context-Switch
2、系统发现事件是缺页异常，尝试确定所需的虚拟页面
3、一旦知道引发缺页异常的虚拟地址，系统检查地址是否有效，并且保护是否与访问一致
4、找到一个空闲（干净的）帧

- 如果没有空闲帧，则运行页面置换以选择一个victim（受害者）
- 如果所选帧是脏的，则将页面安排转移到磁盘，进行上下文切换，暂停引发异常的进程

5、一旦帧变为干净状态，系统查找所需页面的磁盘地址，并安排磁盘操作将其调入（引发缺页异常的进程仍处于暂停状态）
6、当磁盘中断指示页面已经到达时，更新页表，并将帧标记为正常状态
7、将引发缺页异常的指令恢复到其原始状态，并重置程序计数器
8、引发缺页异常的进程被调度，Context-Switch回去

### 性能

处理缺页异常的三个主要活动：服务中断：一般只需要几百条指令；读取页面：需要大量时间；恢复进程：需要少量时间

缺页错误率（$0\leq p \leq 1$）：进程在内存中发现缺页异常的速率

有效访问时间：$\text{EAT} = (\epsilon + t)\alpha + (\epsilon + 2t) (1 - \alpha)$

## 11.7 页面置换

页面置换策略：FIFO、Optimal、LRU、二次机会算法、N次机会时钟算法、NRU算法、老化算法Aging

### FIFO

替换最老的页面：使用一个FIFO队列来跟踪页面的老化（aging）程度

Belady异常：增加帧数反而可能会降低命中率（帧数越少，缺页异常越少）

- Belady's Anomaly会发生在任何页面替换算法中（比如随机替换），只要它不遵循“栈算法”属性（stack algorithm property）
  - 栈算法属性确保当页面帧数量增加时，先前存在的页面集合始终是当页面帧更多时存在的页面集合的子集。换句话说，随着页面帧数的增加，先前存在的页面应始终保留在内存中
- 之后的LRU（最近最少使用）和Optimal（最佳）算法始终遵循栈算法属性，因此它们永远不会受到Belady's Anomaly的影响

### Optimal（MIN）

替换那些在最长时间内不会被使用的页面

### LRU

替换那些在最长时间内没有被使用的页面：基于局部性原理

为了跟踪哪些页面最近最少被使用（将每个页面的最后一次使用时间与之关联），操作系统必须在每次内存引用时进行一些计时工作

- 计数器实现
  - 每个页面都有一个对应的计数器项
  - 每次页面被引用时，通过硬件将时钟寄存器的值复制到计数器中
  - 当需要更换页面时，查看计数器以找到最小的值

### 近似 LRU

通过引用位来近似 LRU（即二次机会算法，Second Chance）：寻找一个在最近的时钟周期内没有被引用的老页面

系统中每个页面有一个引用位（R）。

- 每当引用页面（即读取或写入），引用位被设置为1（由硬件完成）

- 如果要被替换的页面：

  - R = 1：将引用位设置为0；将其放在FIFO队列的末尾；并检查下一个页面。

  - R = 0：替换它。

- 如果所有页面都被引用，那么第二次机会等于FIFO。

### 二次机会算法

高效替代Second Chance算法：时钟算法

将所有页面帧以时钟形式放在一个循环列表中（避免在队列上移动页面）

发生缺页异常时，检查当前指向的页面。

采取的操作取决于R位的值：R = 0：驱逐该页面；R = 1：将R=0并将指针向前移

### N次机会时钟算法

给每个页面N次机会

操作系统为每个页面保持一个计数器：计数扫过的次数

发生页面错误时，操作系统检查使用位：

- 1：清除使用位并清除计数器（在最后一次扫过时被使用）
- 0：增加计数器；如果计数=N，则替换页面

这意味着时钟指针需要扫过N次而页面没有被使用后才会替换该页面

### NRU 算法（Not Recently Used）

通过两个状态位—引用位和修改位来近似LRU（即Not Recently Used，NRU算法）：为那些被修改的页面赋予更高的优先级以减少I/O负担（增强的第二次机会）

- (0, 0)：既不是最近使用的也没有被修改过（最适合替换）
- (0, 1)：不是最近使用的但被修改过（不太理想，需要在替换前写出）
- (1, 0)：最近被使用但是干净的（但可能会很快再次被使用）
- (1, 1)：最近被使用且被修改过（可能会很快再次被使用，并且需要在替换前写出）
- 从最低编号的非空类中随机移除一个页面（可能需要多次在循环队列中搜索）

### 老化算法 Aging

通过额外的引用位来近似LRU（即Aging算法）：保持一个软件计数器来追踪每个页面被引用的次数，并替换计数最小的页面

每个页面关联一个软件计数器

在每个时钟中断时

- 对每个页面的计数器进行右移1位操作（类似于时间/2）
- 并将R位添加到最左边（类似于新引入的刷新了时间）

较大的值表示最近使用的页面：选择01110111页面进行替换，而不是11000100页面