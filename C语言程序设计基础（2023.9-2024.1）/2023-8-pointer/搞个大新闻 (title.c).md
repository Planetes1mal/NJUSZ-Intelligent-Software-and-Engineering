# 搞个大新闻 (title.c)

## 题目描述

为了发布新闻，我们需要遵守标题的规则，即所有单词的首字母大写。

口口已经决定，就由你来写标题。

请勿在代码中出现[和] 及其替代，否则你会获得0分答案错误

### 输入格式

输入一行大小写混杂的英文句子，没有任何标点符号，长度小于 4096 字节

单词长度只受总长度限制。

**数据保证单词之间的空格只有一个** ~~（用%c和getchar读如果出错了请自己debug）~~

### 输出格式

输出一行**只有**每个单词的首字母大写的句子。（即原来单词中大写的非首字母要小写）

### 测试样例

##### Input

------

```
GNU is not Unix
```

##### Output

------

```
Gnu Is Not Unix
```

### 题目注解

0 分并且使用 scanf("%c",...) 或 getchar() 的注意行尾的标志符。



## Code

```c
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

int main()
{
    char *sentence = (char *)malloc(4096 * sizeof(char));
    if (sentence == NULL)
    {
        printf("Memory allocation failed.\n");
        return 1;
    }

    char ch, *ptr = sentence;
    int isFirstChar = 1;
    while ((ch = getchar()) != '\n' && ch != EOF)
    {
        if (isFirstChar || *(ptr - 1) == ' ')
        {
            *ptr = toupper(ch);
            isFirstChar = 0;
        }
        else
        {
            *ptr = tolower(ch);
        }
        ptr++;
    }
    *ptr = '\0';

    printf("%s\n", sentence);

    free(sentence);
    return 0;
}
```

### 实现思路

1. **动态内存分配**：
    - 使用 `malloc` 动态分配一块足够大的内存，大小为 4096 字节，用于存储输入的句子。这避免了静态数组的使用。

2. **读取输入**：
    - 使用 `getchar` 函数逐字符读取输入，直到遇到换行符（'\n'）或文件结束标志（EOF）。

3. **处理字符串**：
    - 创建一个指针 `ptr`，指向动态分配的内存（即句子的开始）。
    - 使用 `isFirstChar` 标志来标记是否遇到了一个新单词的开始。如果是句子的开始或者前一个字符是空格，则 `isFirstChar` 为真。
    - 对于每个读入的字符 `ch`：
        - 如果 `isFirstChar` 为真，或者 `ptr` 前一个字符是空格，则将 `ch` 转换为大写，并存储在 `ptr` 指向的位置。
        - 否则，将 `ch` 转换为小写，并存储在 `ptr` 指向的位置。
    - 每次存储后，将 `ptr` 向前移动一位。
    - 读取完所有字符后，将 `ptr` 指向的位置设置为字符串终结符（'\0'），表示字符串结束。

4. **输出结果**：
    - 打印处理后的句子。

5. **释放内存**：
    - 在所有操作完成后，使用 `free` 函数释放之前分配的内存。

### 时间复杂度

- **时间复杂度为 O(n)**：其中 n 是输入句子的长度。程序对每个字符进行一次操作，包括大小写转换和指针移动，因此时间复杂度与句子长度成线性关系。

### 空间复杂度

- **空间复杂度为 O(1)**：虽然使用了动态内存分配，但分配的内存大小是固定的（4096 字节），并不随输入句子的长度变化。因此，空间复杂度是常量。

### 特别说明

- 这个实现避免了使用数组和数组下标表示法，完全通过指针操作来访问和修改内存中的数据。
- 需要注意的是，这种方法假设输入的句子长度不会超过 4096 字节。如果实际应用中有可能超过这个长度，应该考虑更复杂的内存管理策略，比如动态调整内存大小。