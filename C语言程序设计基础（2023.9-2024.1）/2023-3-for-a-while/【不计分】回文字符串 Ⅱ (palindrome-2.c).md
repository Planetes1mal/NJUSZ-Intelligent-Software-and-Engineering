# 【不计分】回文字符串 Ⅱ (palindrome-2.c)

## 题目描述

老师给出了一个回文字符串 s，然而里面有些字符丢失了，这些位置用 `?` 表示，他想请你帮助他还原这个字符串。

这一周目中，字符串中的 `?` 可能非常多，即使聪明如你也无法准确还原。形式化地说，假设 $s = s_1 s_2…s_n$，可能存在（0 个或多个）$1 \leq i \leq n$，$s_i = s_{n-i+1} = ?$。为了蒙混过关，你准备从字符串 `"00", "01", "02", ..., "99"` 中选择一些**不同**的字符串，镜像地填补到这些位置上，使得最后还原得到的串仍然是一个回文串。

如果一个字符串翻转之后与自身完全相同，则称这个字符串是“回文的”。比如 `"abccba"、"9997999"` 是回文的，而 `"rikka"` 则不是回文的。

### 输入格式

输入包含两行，第一行包含一个整数 n ，表示字符串长度，第二行包含一个长度为 n 的字符串。

$n \leq 100000$，字符串中的字符只可能为 26 个大写字母、26 个小写字母、10 个数字和 `?` 之一。

保证对称位置都为 `?` 的位置对数量不超过 100 个；当 n = 2k + 1 时，$s_{k+1} \neq ?$

### 输出格式

输出一行一个字符串，为“修复”得到的字符串。

可能有多个符合条件的答案，你可以任意输出一个。

输出字符串中的字符只可能为 26 个大写字母、26 个小写字母、10 个数字

### 测试样例

##### Input

------

```
10
rikk?akki?
```

##### Output

------

```
rikkaakkir
```

##### Input

------

```
13
m?yi??k??iya?
```

##### Output

------

```
mayi9801k1089iyam
```

### 题目注解

#### 样例 2 解释

注意到 `k` 两侧的 4 个对应的问号，在样例输出中一个补上了 `"98"` ，另一个补上了 `"01"` ，在这个样例中， `mayi0001k1000iyam` 和 `mayi7619k9167iyam` 也都是正确的答案，甚至 `mayi9898k8989iyam`也是正确的答案（可视作`"98"` 和 `"89"` 分别使用了一次），但 `mayi9999k9999iyam` 不是正确的答案，因为 `"99"` 不能使用两次。

#### By 出题助教

为了写这道题的 SPJ ，使用了一些不清真的方式绕过了 OJ 先检测样例的限制，无论样例输出什么，都会被判定为正确。

#### Hint

一定要把整个字符串填好了才能输出吗？

提示：不妨一个字符一个字符输出，若碰到未消除的问号，便输出一个**二位数**。



## 题解

### 思路

这道题的目标是从给定的回文字符串中还原出完整的字符串，其中可能存在一些位置用'?'表示，需要从字符串 `"00", "01", "02", ..., "99"` 中选择不同的字符串，镜像地填补到这些位置上，以便还原得到的串仍然是一个回文串。

### 解题方法

1. 读取输入的回文字符串。
2. 创建字符串的镜像，将其命名为字符串 `b`。
3. 遍历字符串 `a`，如果当前字符是'?'而镜像字符串 `b` 对应位置不是'?'，则用 `b` 中的字符替换 `a` 中的'?'，确保字符串 `a` 保持回文的性质。
4. 然后处理回文字符串的前半部分，将前半部分的'?'替换为数字，并输出。同时，保持前半部分的回文性质。
5. 最后处理回文字符串的后半部分，将后半部分的'?'替换为数字，并输出。同样，保持后半部分的回文性质。

这个算法能够保持回文性质，因为它首先处理回文字符串的前半部分，然后处理后半部分，确保了字符串的回文性。

此解法具体实现了如上思路，通过遍历回文字符串 `a` 和它的镜像 `b`，以及使用一个额外的数组 `c` 来存储替换'?'后的数字。然后根据不同情况进行输出，确保了回文性质的保持。

最后，程序输出修复得到的字符串。

### 复杂度

- 时间复杂度：遍历字符串一次，$O(n)$。

- 空间复杂度：使用了额外的数组 `b` 和 `c`，空间复杂度为$O(n)$。

### Code

```c

```

