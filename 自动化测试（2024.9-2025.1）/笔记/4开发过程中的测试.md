# 4 开发过程中的测试

## 4.1 单元测试

### 4.1.1 概念

单元测试集中检验软件设计的最小单元——模块，可以是函数、过程或类对象等

正式测试之前必须先通过编译程序检查并且改正所有语法错误，然后用详细设计描述作指南，对重要的执行通路进行测试，以便发现模块内部的错误

单元测试可以使用白盒测试法，而且对多个模块的测试可以并行地进行

单元测试（模块测试）是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确。通常而言，一个单元测试是用于判断某个特定条件（或者场景）下某个特定函数的行为

单元测试是在软件开发过程中要进行的最低级别的测试活动，在单元测试活动中，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。

单元测试不仅仅是作为无错编码一种辅助手段在一次性的开发过程中使用，单元测试必须是可重复的，无论是在软件修改，或是移植到新的运行环境的过程中。因此，所有的测试都必须在整个软件系统的生命周期中进行维护

### 4.1.2 原理

在单元测试期间主要评价模块的下述五个特性：

- 模块接口

  - 在对接口进行测试时主要检查下述各点：
    （1）参数数目和由调用模块送来的变元的数目是否相等？
    （2）参数的属性和变元的属性是否匹配？
    （3）参数和变元的单位系统是否匹配？
    （4）传送给被调用模块的变元的数目是否等于那个模块的参数的数目？
    （5）传送给被调用模块的变元属性和参数的属性是否一致？
    （6）传送给被调用模块的变元的单位系统和该模块参数的单位系统是否一致？
    （7）传送给内部函数的变元属性、数目和次序是否正确？
    （8）是否修改了只做输入用的变元？
    （9）全程变量的定义和用法在各个模块中是否一致？ 
  - 如果一个模块完成外部的输入或输出时，还应该再检查下述各点：
    （1）文件属性是否正确？
    （2）打开文件语句是否正确？
    （3）格式说明书与输入／输出语句是否一致？
    （4）缓冲区大小与记录长度是否匹配？
    （5）使用文件之前先打开文件了吗？
    （6）文件结束条件处理了吗？
    （7）输入／输出错误检查并处理了吗？
    （8）输出信息中有文字书写错误吗？

- 局部数据结构

  对于一个模块而言，局部数据结构是常见的错误来源。应该仔细设计测试方案，以便发现下述类型的错误：
  （1）错误的或不相容的说明；
  （2）使用尚未赋值或尚未初始化的变量；
  （3）错误的初始值或不正确的缺省值；
  （4）错误的变量名字（拼写错或截短了）；
  （5）数据类型不相容；
  （6）上溢、下溢或地址异常。

- 边界条件：保证模块单元在极限或某些严格条件下仍然正确执行，例如错误往往出现在一个 n 元数组的第 n 个元素被处理的时候，或者一个 i 次循环的第 i 次执行，或允许的最大值或最小值出现的时候。用边际值方法可以有效地发现这类错误。

- 独立路径

  - 在控制结构中的所有路径覆盖法或基本路径覆盖法都是需要测试的，以保证在一个模块中的所有语句或分支元素等都能被执行一次
  - 测试用例应当能够发现由于错误计算、不正确的比较或者不正常的控制流而产生的错误如：误解的或不正确的算术优先级；混合模式的操作；不正确的初始化；精度不够准确；表达式的不正确符号表示
  - 当比较和控制流紧密地耦合在一起，即控制流的转移是在比较之后发生的，此时测试用例应当能够发现的错误如：不同数据类型的比较；不正确的逻辑操作或优先级；应该相等的地方由于精度的错误而不能相等；不正确的比较或者变量；不正常的或者不存在的循环终止；当遇到分支循环的时候不能退出；不适当地修改循环变量等

- 错误处理路径

  - 要对所有处理错误的路径进行测试，好的设计要求错误条件是可以预料的，而当错误真的发生的时候，错误处理路径被建立，以重定向或者终止处理
  - 在错误处理部分应当考虑潜在的错误包括：对错误描述不够准确；所报的错误与真正遇到的错误不一致；错误条件在错误处理之前就引起了系统异常；异常条件处理不正确；错误描述没有提供足够的信息来帮助确定错误发生的位置

### 4.1.3 过程

1、代码审查及走查

2、测试软件

### 4.1.4 优缺点

- 它是一种验证行为。 
  程序中的每一项功能都是测试来验证它的正确性。它为以后的开发提供支缓。就算是开发后期，我们也可以轻松的增加功能或更改程序结构，而不用担心这个过程中会破坏重要的东西。而且它为代码的重构提供了保障。这样，我们就可以更自由的对程序进行改进。
- 它是一种设计行为。 
  编写单元测试将使我们从调用者观察、思考。特别是先写测试（test-first），迫使我们把程序设计成易于调用和可测试的，即迫使我们解除软件中的耦合。 
- 它是一种编写文档的行为。 
  单元测试是一种无价的文档，它是展示函数或类如何使用的最佳文档。这份文档是可编译、可运行的，并且它保持最新，永远与代码同步。 
- 它具有回归性。 
  自动化的单元测试避免了代码出现回归，编写完成之后，可以随时随地的快速运行测试。 

## 4.2 集成测试

### 4.2.1 概念

在单元测试的基础上，我们通常需要对由经过单元测试的模块组装起来形成的一个子系统进行的测试，这样的测试被称为子系统测试。子系统测试时重点测试模块的接口。

而对由经过测试的子系统测试组装成的系统进行的测试则称为系统测试。在系统测试中发现的往往是软件设计中的错误，也可能发现需求说明中的错误。

我们不难看出，不论是子系统测试还是系统测试都兼有检测和组装的含义，这样的测试通常就称为集成测试。
集成测试又叫组装测试。

### 4.2.2 非渐增式测试和渐增式测试

根据模块组成程序时的两种不同方法，集成测试方法可以分为两类一是非渐增式测试，一是渐增式测试。

- 渐增式测试是指把下一个要测试的模块同已经测试好的模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试。这种每次增加一个模块的方法称为渐增式测试。这种方法同时完成单元测试和集成测试。
- 非渐增式测试是先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序。

两种方法的优缺点对比如如下：

- 第一、由于渐增式的测试方法是利用已测试过的模块作为部分测试软件，因此编写测试软件的工作量比较小。而非渐增式测试方法分别测试每个模块，需要编写的测试软件通常比较多，所需工作量较大。
- 第二、渐增式测试可以较早发现模块间的接口错误。非渐增式测试最后才把模块组装在一起，因此接口错误发现较晚。
- 第三、如果发现错误，渐增式测试方法较易查找错误原因。因为如果发生错误往往和最近加进来的那个模块有关。而非渐增式测试一下子把所有模块组合在一起，如果发现错误很难发现确诊。
- 第四、渐增式测试方法把已经测试好的模块和新加进来的那个模块一起测试，已测试好的模块可以在新的条件下受到新的检验，使程序的测试更彻底。
- 第五、由于测试每个模块时所有已经测试完的模块也要跟着一起运行，因此，渐增式测试需要较多的机器时间。
- 第六、使用非渐增式测试方法可以并行测试所有模块，因此能充分利用人力，工程进度可以加快。
  总的来看，渐增式测试方法比较好。

### 4.2.3 方法

- 自顶向下集成：从主控制模块（“主程序”）开始，沿着软件的控制层次向下移动，从而逐渐把各个模块结合起来。在把附属于（以及最终附属于）主控制模块的那些模块组装到软件结构中去时，或者使用深度优先的策略，或者使用宽度优先的策略。
- 自底向上集成：从“原子”模块（即在软件结构最低层的模块）开始组装和测试。因为是从底部向上结合模块，总能得到需要的下层模块处理功能，所以不需要存根程序

## 4.3 系统测试

1、概念：将整个软件系统视为一个整体来进行测试

2、目标：重点测试软件产品的各项功能是否满足用户的要求，还包括性能、安全性、兼容性、可用性等软件特性及方面的测试 

## 4.4 冒烟测试

daily build 就是把一个软件项目的所有的最新的代码从配置库中取出,然后从头进行编译,链接和运行。更甚者可以再运行测试包对软件的主要功能进行测试，发现并报告错误的整个过程。通常由工具自动完成。冒烟测试就是在每日build建立后，对系统的基本功能进行简单的测试。

优缺点：

- 测试周期短，响应速度快
- 能最小化集成风险
- 能减小产品低质量的风险
- 能简单化错误诊断

## 4.5 验收测试

验收测试的任务：验证软件的有效性

- 如果软件的功能和性能如同用户所合理地期待的那样，则软件是有效的
- 在需求分析阶段产生的文档准确地描述了用户对软件的合理期望，因此是软件有效的标准，也是验收测试的基础

验收测试的目的是向未来的用户表明系统能够像预定要求那样工作。验收测试的范围与系统测试类似，但是也有一些差别，例如：
  ⑴  某些已经测试过的纯粹技术性的特点可能不需要再次测试；
  ⑵  对用户特别感兴趣的功能或性能，可能需要增加一些测试；
  ⑶  通常主要使用生产中的实际数据进行测试；
  ⑷  可能需要设计并执行一些与用户使用步骤有关的测试。

验收测试必须有用户积极参与，或者以用户为主进行。用户应该参加设计测试方案，使用用户接口输入测试数据并且分析评价测试的输出结果。为了使用户能够积极主动地参与验收测试，特别是为了使用户能有效地使用这个系统，通常在验收之前由开发部门对用户进行培训。

验收测试一般使用黑盒测试法。应该仔细设计测试计划和测试过程，测试计划包括要进行的测试的种类和进度安排，测试过程规定用来检验软件是否与需求一致的测试方案。通过测试要保证软件能满足所有功能要求，能达到每个性能要求，文档资料是准确而完整的，此外，还应该保证软件能满足其他预定的要求（例如，可移植性、兼容性和可维护性等等）。
验收测试有两种可能的结果：
⑴  功能和性能与用户要求一致，软件是可以接受的；
⑵  功能或性能与用户的要求有差距。

在这个阶段发现的问题往往和需求分析阶段的差错有关，涉及的面通常比较广，因此解决起来也比较困难。为了确定解决验收测试过程中发现的软件缺陷或错误的策略，通常需要和用户充分协商。

验收测试的一个重要内容是复查软件配置。复查的目的是保证软件配置的所有成分都齐全，各方面的质量都符合要求，文档与程序一致，具有维护阶段所必须的细节，而且已经编排好目录。

除了按合同规定的内容和要求；由人工审查软件配置之外，在验收测试的过程中应该严格遵循用户指南以及其他操作程序，以便检验这些使用手册的完整性和正确性。必须仔细记录发现的遗漏或错误，并且适当地补充和改正。

## 4.6 回归测试

1、概念

回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。自动回归测试将大幅降低系统测试、维护升级等阶段的成本 

回归测试作为软件生命周期的一个组成部分，在整个软件测试过程中占有很大的工作量比重，软件开发的各个阶段都会进行多次回归测试。在渐进和快速迭代开发中，新版本的连续发布使回归测试进行的更加频繁，而在极端编程方法中，更是要求每天都进行若干次回归测试。因此，通过选择正确的回归测试策略来改进回归测试的效率和有效性是非常有意义的。 

2、方法

## 4.7 α测试

α测试是由一个用户在开发环境下，进行的测试，也可以是开发机构内部的用户在模拟实际操作环境下进行的测试。α测试的目的是评价软件产品的FLURPS（即功能、局域化、可使用性、性能和支持），尤其注重产品的界面和特色。α测试人员是除产品开发人员之外首先见到产品的人，他们提出的功能和修改意见是特别有价值的。α测试可以从产品编码结束之时开始，或在模块测试完成之后开始，也可在验收测试过程中产品达到一定的稳定和可靠程度以后再开始。

## 4.8 β测试

经过α测试调整的软件产品称为β版本。 β测试是由软件的多个用户在实际使用环境下进行的测试，这些用户返回有关错误信息给开发者。测试时，开发者通常不在测试现场。因而，β测试是在开发者无法控制的环境下进行的软件现场应用。在β测试中，由用户记下遇到的所有问题，包括真实的以及主观认定的，定期向开发者报告。β测试主要衡量产品的FLURPS，着重于产品的支持性，包括文档，客户培训和支持产品生产能力。
只有当α测试达到一定的可靠程度时，才能开始β测试。它处在整个测试的最后阶段。同时，产品的所有手册文本也应该在此阶段完全定稿。

## 4.9 λ测试

λ是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处理即可上市发行 

## 4.10 不稳定测试

在相同代码版本上，多次执行同一个测试用例却观察到不同的测试结果



## 4.11 基于性质的测试

基于性质的测试是一种测试方法，它侧重于验证软件系统是否满足一组预定义的性质（properties）。这种方法通常使用随机生成的测试数据来检查系统是否保持这些性质。









# 思考题

1 简述单元测试的优缺点
2 集成测试的策略有几种？简述各自特点
3 系统测试的目标是什么？
4 验收测试主要测试什么？
5 为什么要进行回归测试？
6 α测试主要检测软件哪些方面的问题？
7 α测试与β测试的区别在哪里？
8 冒烟测试有什么作用？
9 什么是Flaky Test？Property-Based  Testing？
10 在开发过程中有哪些主要的阶段性测试？