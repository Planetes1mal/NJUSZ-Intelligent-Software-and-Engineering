# 运算方法和运算部件

## 3.1 高级语言和机器指令中的运算

### 3.1.1 C语言程序中涉及的运算

1. 算术运算（最基本的运算）
   - 无符号数、带符号整数、浮点数的运算


2. 按位运算

   - 用途：对一个位串实现“掩码”（mask）操作或相应的其他处理（主要用于对多媒体数据或控制信息进行处理）
   
   
      - 操作：
   
         	- - 按位或：“|”
      - 按位与：“&”
      - 按位取反：“~”
      - 按位异或：“^”
   


3. 逻辑运算

   - 用途：用于关系表达式的运算：例如，if （x>y and i<100）then ……中的“and”运算
   
   
      - 操作：
   
         	- - “‖”：“或”运算
            
         - “&&”：“与”运
         - !”：“非”运算
   
   
      - 与按位运算的差别
   
         	- - 符号表示不同
      - 运算过程不同：按位~ 整体
   - 结果类型不同：位串~ 逻辑值
   


4. 移位运算

   - 用途：

   	- 提取部分信息
   	- 扩大或缩小数值的2、4、8…倍
   
   
      - 操作：左移:：x<<k；右移： x>>k
        - 
          不区分是逻辑移位还是算术移位，由x的类型确定
   
   
   - 无符号数：逻辑左移、逻辑右移
   
   
   - 高（低）位移出，低（高）位补0
   
   - 问题：何时可能发生溢出？如何判断溢出？（若高位移出的是1，则左移时发生溢出）
   
   
   - 带符号整数：算术左移、算术右移
     - 左移：高位移出，低位补0。（溢出判断：若移出的位不等于新的符号位，则溢出）
     - 右移：低位移出，高位补符，可能发生数据丢失。
   
5. 位扩展和位截断运算

   - 用途：在进行类型转换时，可能需要数据的扩展或截断


   - 操作：没有专门的操作运算符，根据类型转换前后数据长短来确定是扩展还是截断

   - ”扩展“：短数转为长数；“截断”，长数转为短数

     - 扩展

       - 无符号数：0扩展，即：前面补0

       - 带符号整数：符号扩展，即：前面补符号

     - 截断
       - 强行将一个长数的高位丢弃，故可能会发生“溢出”

### 3.1.2 MIPS指令中涉及的运算

![image-20231012150805522](C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231012150805522.png)

- 涉及到的操作数：32/16位逻辑数
- 涉及到的操作：按位与/ 按位或/ 按位或非/ 左移/ 右移

![image-20231012152734941](C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231012152734941.png)

- 涉及到的操作数：32/16位 无符号数， 32/16位带符号数

- 涉及到的操作：加 / 减 /  乘 / 除（有符号 / 无符号）。

![image-20231012152811067](C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231012152811067.png)

- 涉及到的操作数： 32/16位带符号数（偏移量可以是负数）
- 涉及到的操作：加 / 减 / 符号扩展 / 0扩展

![image-20231012152827470](C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231012152827470.png)

- 涉及到的浮点操作数： 32位单精度 / 64位双精度浮点数
- 涉及到的浮点操作：加 / 减 / 乘 / 除

- MIPS提供专门的浮点数寄存器：
  - 32个32位单精度浮点数寄存器：\$ f0, \$ f1, ……, $ f31
  - 连续两个寄存器（一偶一奇）存放一个双精度浮点数

![image-20231012153025953](C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231012153025953.png)

- 涉及到的浮点操作数： 32位单精度浮点数

- 涉及到的浮点操作：传送操作（与定点传送一样）

- 涉及到定点操作：加/ 减（用于地址运算）

- 例：实现将两个浮点数从内存取出相加后再存回到内存的指令序列为：

  ```assembly
    lwcl $ f1, x($ s1)
  
    lwcl $ f2, y($ s2)
  
    add.s $ f4, $ f1, $ f2
  
    swlc $ f4, z(s3)
  ```

## 3.2 基本运算部件

### 3.2.1 全加器和加法器

#### 全加器

输入为加数、被加数和低位进位 $C_{in}$，输出为和 $F$、进位 $C_{out}$

<img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231012154857027.png" alt="image-20231012154857027" style="zoom:80%;" />

#### 串行进位加法器

<img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231012155237753.png" alt="image-20231012155237753" style="zoom:80%;" />

### 3.2.2 并行进位加法器

- 为什么用先行进位方式？

  串行进位加法器采用串行逐级传递进位，电路延迟与位数成正比关系。因此，现代计算机采用一种先行进位（Carry look ahead）方式。

- 如何产生先行进位？

  定义辅助函数：Gi=XiYi…进位生成函数

  ​                        Pi=Xi+Yi…进位传递函数
  通常把实现上述逻辑的电路称为进位生成/传递部件

- 全加逻辑方程：$F_i=X_i⊕Y_i⊕C_i，C_{i+1}=X_iY_i+(X_{i-1}+Y_{i-1})C_{i-1}=G_i+P_iC_i (i=0,1,…n)$
  $$
  \begin{flalign}
  设n=4,则：\\
  &C_1=G_0+P_0C_0 \\
  &C_2=G_1+P_1C_1=G_1+P_1G_0+P_1P_0C_0 \\
  &C_3=G_2+P_2C_2=G_2+P_2G_1+P_2P_1G_0+P_2P_1P_0C_0 \\
  &C_4=G_3+P_3C_3=G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1G_0+P_3P_2P_1P_0C_0 &
  \end{flalign}
  $$
  由上式可知: 各进位之间无等待，相互独立并同时产生。通常把实现上述逻辑的电路称为**4位先行进位部件**（4位CLU）

  <img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231012160657050.png" alt="image-20231012160657050"  />

- **全先行进位加法器**(CLA)：所有进位独立并同时生成

<img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231012160717469.png" alt="image-20231012160717469" style="zoom:80%;" />
$$
\begin{flalign}
& G_i=X_iY_i \\
& P_i=X_i+Y_i（或P_i=X_i⊕Y_i）\\
& F_i=X_i⊕Y_i ⊕C_{i-1} &
\end{flalign}
$$

### 3.2.3 带标志加法器

<img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231012161708897.png" alt="image-20231012161708897" style="zoom:80%;" />

### 3.2.4 算术逻辑部件

<img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231012171555934.png" alt="image-20231012171555934" style="zoom: 33%;" />

- 进行基本算术运算与逻辑运算

  - 无符号整数加、减

  - 带符号整数加、减

  - 与、或、非、异或等逻辑运算

- 核心电路是整数加/减运算部件
  - 输出除和/差等，还有标志信息
  - 有一个操作控制端（ALUop），用来决定ALU所执行的处理
  - 功能。ALUop的位数k决定了操作的种类例如，当位数k为3时，
  - ALU最多只有 $2^3=8$ 种操作。

| <img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231012172731497.png" alt="image-20231012172731497"  /> | <img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231012172743017.png" alt="image-20231012172743017" style="zoom: 50%;" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231012172833851.png" alt="image-20231012172833851" style="zoom: 33%;" />

## 3.3 定点数运算

### 3.3.1 补码加减运算

1. 补码加减运算公式
$$
[X+Y]_补= [X]_补+ [Y]_补  (\mod 2^n ) \\
[X-Y]_补= [X]_补+ [–Y]_补  (\mod 2^n )
$$

2. 补码加减运算要点和运算部件

   - 加、减法运算统一采用加法来处理

   - 符号位(最高有效位MSB)和数值位一起参与运算

   - 直接用ALU实现两个数的加运算（模运算系统）
   
   - [ ] 问题：模是多少？
   
     - 运算结果的高位丢弃，保留低n位，相当于对和数取模 $2^n$
   
   
     - 实现减法的主要工作在于：求 $[–Y]_补$
   
   
   - [ ] 问题：如何求 $[–Y]_补$：$[–B]_补=\overline{B}+1$
   
     - 当控制端Sub为1时，做减法，实现A–B
   
     - 当控制端Sub为0时，做加法，实现A+B
   

利用带标志加法器，可构造整数加/减运算器，进行以下运算：

- 无符号整数加、无符号整数减
- 带符号整数加、带符号整数减
- 当Sub为1时，做减法；当Sub为0时，做加法

| <img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231012215828108.png" alt="image-20231012215828108" style="zoom:50%;" /> | <img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231012220435114.png" alt="image-20231012220435114" style="zoom: 33%;" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231012220636636.png" alt="image-20231012220636636" style="zoom: 25%;" />

### 3.3.2 原码加减运算

### 3.3.3 原码乘法运算

手算乘法的特点：
① 每步计算：$X×y_i$，若 $y_i = 0$，则得 $0$；若 $y_i = 1$，则得 $X$
② 把①求得的各项结果 $X× y_i$ 逐次左移，可表示为 $X× y_i×2^{-i}$
③ 对②中结果求和，即 $\sum (X× y_i×2^{-i})$，这就是两个无符号数的乘积

计算机内部稍作以下改进：
① 每次得 $X×y_i$ 后，与前面所得结果累加，得到 $P_i$，称之为部分积。因为不等到最后一次求
和，减少了保存各次相乘结果 $X×y_i$ 的开销。
② 每次得 $X×y_i$ 后，不将它左移与前次部分积 $P_i$ 相加，而将部分积 $P_i$ 右移后与 $X×y_i$ 相加。因
为加法运算始终对部分积中高 $n$ 位进行。故用 $n$ 位加法器可实现二个 $n$ 位数相乘。
③ 对乘数中为“1”的位执行加法和右移，对为“0”的位只执行右移，而不执行加法运算。

<img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231012221258401.png" alt="image-20231012221258401" style="zoom: 33%;" />

- 用于浮点数尾数乘运算

- 符号与数值分开处理：积符用两个符号异或得到，数值用无符号乘法运算

### 3.3.4 补码乘法运算

<img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231015213836476.png" alt="image-20231015213836476" style="zoom: 33%;" />

<img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231015213909062.png" alt="image-20231015213909062" style="zoom:33%;" />

<img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231015213932228.png" alt="image-20231015213932228" style="zoom:33%;" />

### 3.3.5 快速乘法器

- 前面介绍的乘法部件的特点

  - 通过一个ALU多次做“加/减+右移”来实现

    - 一位乘法：约n次“加+右移”

    - 两位乘法：约n/2次“加+右移”

	所需时间随位数增多而加长，由时钟和控制电路控制

- 设计快速乘法部件的必要性
	- 大约1/3是乘法运算

- 快速乘法器的实现（由特定功能的组合逻辑单元构成）
	- 流水线方式
  - 硬件叠加方式（如：阵列乘法器）

<img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231015214257621.png" alt="image-20231015214257621" style="zoom: 40%;" />

<img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231015214328945.png" alt="image-20231015214328945" style="zoom:40%;" />

### 3.3.6 原码除法运算

<img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231015214450885.png" alt="image-20231015214450885" style="zoom:33%;" />

- 除前预处理
  ①若被除数=0且除数≠0，或定点整数除法时|被除数|<|除数|，则商为0，不再继续
  ②若被除数≠0、除数=0，则发生“除数为0”异常（浮点数时为∞）
  （若浮点除法被除数和除数都为0，则有些机器产生一个不发信号的NaN，即“quiet NaN”
  ③只有当被除数和除数都≠ 0，且商≠ 0时，才进一步进行除法运算。

- 计算机内部无符号数除法运算
  - 与手算一样，通过被除数（中间余数）减除数来得到每一位商
    - 够减上商1；不够减上商0（从msb→lsb得到各位商）
  - 基本操作为减（加）法和移位，故可与乘法合用同一套硬件

两个n位数相除的情况：
(1)定点正整数（即无符号数）相除：在被除数的高位添n个0
(2)定点正小数（即原码小数）相除：在被除数的低位添加n个0
这样，就将所有情况都统一为：一个2n位数除以一个n位数

<img src="C:\Users\111\AppData\Roaming\Typora\typora-user-images\image-20231015220354844.png" alt="image-20231015220354844" style="zoom:33%;" />

1. 恢复余数除法

   
