# 实验三: 类型转换和移位操作运算

## 一、实验目的

了解高级语言中数据类型的转换和移位操作结果，从而能更好地理解指令系统设计和计算机硬件设计所需满足的要求和需要考虑的问题

## 二、实验要求

编程实现以下各种操作：

（1） 给定一个 short 型数据 -12345，分别转换为 int、unsigned short、unsigned int、float 类型的数据;

（2）给定一个 int 型数据 2147483647，分别转换为 short、unsigned short、unsigned int、float 类型的数据;

（3）给定一个 float 型数据 123456.789e5，转换成 double 型数据; 

（4）给定一个double 型数据 123456.789e5，转换成 float 型数据;

（5）按 short 和 unsigned short 类型分别对-12345 进行左移 2 位和右移 2 位操作。 

要求分别用十进制和十六进制形式打印输出以上各种操作的结果。

根据实验结果，回答下列问题

（1）无符号数和带符号整数的扩展操作方式是否相同？各是如何进行的？

无符号数和带符号整数的扩展操作方式不相同。它们的扩展方式如下：

- 无符号数（unsigned）扩展操作（例如将 short 转换为 unsigned int）：无符号数的扩展操作会保持二进制位不变，并在高位填充0。这意味着不会出现符号位扩展，只是在高位添加零以匹配目标数据类型的位数。
- 带符号整数（signed）扩展操作（例如将 short 转换为 int）：带符号整数的扩展操作会使用符号位进行填充。如果原始数据是正数，则在高位填充0；如果原始数据是负数，则在高位填充1。

（2）补码整数（如 int 型数）是否总能转换为等值的 float 类型数据？为什么？

不能。因为 int 型数据有效位数为 32 位，而 float 型数据的尾数部分是 23 位，加上隐藏的高位 1 位，实际精度为 24 位，所以int精度比 float 高，所以 int 型数据向 float 型数据转换时有效位数可能会丢失。

（3）float 型数据是否总能转换成等值的 double 型数据？为什么？

能。 double型数据的精度和范围均高于float型，所以float型向double型转换时是中等值。

（4） 长数被截断成短数后可能发生什么现象？为什么？

当长数（例如int）被截断为短数（例如short）时，可能会发生以下现象：

1. **丢失高位信息：** 截断会导致高位的一些二进制位被丢弃。这意味着截断后的数值将失去原始数值的一部分。
2. **溢出：** 如果原始长数的值超过了短数类型所能表示的范围，截断操作可能导致溢出。这意味着结果将不再准确代表原始值，而是循环或截断到新的数值，通常是模数算术的结果。
3. **符号位问题：** 如果原始长数是带符号的，而截断到短数后，新的数值可能会改变符号，因为符号位的位置不同。这可能导致截断后的值与原始值的符号不一致。

截断发生的原因是，长数和短数通常使用不同的字节大小来存储，短数的字节大小比长数小。截断操作强制将原始数值适应新的数据类型，因此可能导致上述问题。

（5）C 语言中移位操作规则与操作对象的数据类型有关吗？

C语言中移位操作的规则与操作对象的数据类型有关。有符号数执行算数移位，无符号数执行逻辑移位

（6）左移 2 位和右移 2 位操作分别相当于扩大和缩小几倍？

移 2 位和右移 2 位操作在数值上分别相当于扩大和缩小 4 倍。

1. **左移 2 位（<< 2）：** 这意味着将操作对象的所有位向左移动 2 位，同时在右侧填充 0 。这等效于将原始数值乘以 2 的平方，也就是 4。
2. **右移 2 位（>> 2）：** 这意味着将操作对象的所有位向右移动 2 位，同时在左侧填充符号位（对于带符号整数）或者 0（对于无符号整数）。这等效于将原始数值除以 2 的平方，也就是 4。