# 第五章 数据库完整性

1、数据库的完整性：

- 数据的正确性
- 数据的相容性

2、完整性 vs 安全性

3、完整性机制

- 定义完整性约束条件的机制
- 完整性检查的方法
- 违约处理：拒绝（NO ACTION）执行该操作、级连（CASCADE）执行其他操作

4、完整性约束定义的分类

（1）按照定义对象分类

- 与表有关的约束：列约束和表约束
- 域约束
- 断言

（2）按照约束状态分类

- 静态约束：与表有关的约束，域约束、断言
- 动态约束：触发器

## 5.1 实体完整性

### 5.1.1 实体完整性定义

- 关系模型的实体完整性定义：在 CREATE TABLE 命令中，用 PRIMARY KEY 定义主码，或者用 UNIQUE + NOT NULL 定义唯一码

- 单列构成的码有两种说明方法

  - 定义为列级约束条件（作为某一列的定义成分）

    ```sql
    CREATE TABLE
        Student (
            Sno CHAR(9) PRIMARY KEY,
            Sname CHAR(20) NOT NULL,
            Ssex CHAR(2),
            Sage SMALLINT,
            Sdept CHAR(20)
        )
    ```

  - 定义为表级约束条件（作为表的定义成分）

    ```sql
    CREATE TABLE
        Student (
            Sno CHAR(9),
            Sname CHAR(20) NOT NULL,
            Ssex CHAR(2),
            Sage SMALLINT,
            Sdept CHAR(20),
            PRIMARY KEY (Sno)
        );
    ```

- 对多个列构成的码只有一种说明方法：定义为表级约束条件 

  ```sql
  CREATE TABLE
      SC (
          Sno CHAR(9) NOT NULL,
          Cno CHAR(4) NOT NULL,
          Grade SMALLINT,
          PRIMARY KEY (Sno, Cno) /*只能在表级定义主码*/
      );
  ```

### 5.1.2 实体完整性检查和违约处理

插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查。包括：

- 检查主码值是否唯一，如果不唯一则拒绝插入或修改
  - 进行全表扫描：依次判断表中每一条记录的主码值与将插入记录上的主码值（或者修改的新主码值）是否相同。（耗时）
  - 在主码上自动建立一个索引，如 B+ 树索引
- 检查主码的各个列是否为空，只要有一个为空就拒绝插入或修改

## 5.2 参照完整性

### 5.2.1 参照完整性定义

在 CREATE TABLE 命令中用 FOREIGN KEY 短语定义外码，用 REFERENCES 短语指明这些外码参照哪些表的主码
单列构成的外码，既可以作为列级约束、也可以作为表级约束来说明
多列构成的外码，只能作为表级约束来说

### 5.2.2 参照完整性检查和违约处理

1. 一个参照完整性将两个表中的相应元组联系起来
2. 对被参照表和参照表进行增删改操作时有可能破坏参照完整性，必须进行参照完整性检查

<img src="./5数据库完整性/image-20240611162459988.png" alt="image-20240611162459988" style="zoom:67%;" />

3. 参照完整性违约处理
   - 拒绝（NO ACTION）执行
   - 级联（CASCADE）操作：当删除或修改被参照表（Student）的一个元组造成了与参照表（SC）的不一致，则删除或修改参照表中的所有造成不一致的元组
   - 设置为空值（SET-NULL）：对于参照完整性，除了应该定义外码，还应定义外码列是否允许空值

## 5.3 用户定义的完整

1. 针对某一具体应用的数据必须满足的语义要求
   - 列级约束：单个列上的约束条件
     - 列值非空：NOT NULL
     - 列值唯一：UNIQUE
     - 定义列值应该满足的条件：CHECK <条件表达式>
   - 表级约束：元组上的约束条件（涉及单个或多个列）：同单个列上的列级约束相比，表级约束可以设置不同列之间的取值的相互约束条件
     - 列值唯一：UNIQUE(<列名> [, <列名>]...)
     - 定义列值应该满足的条件：CHECK <条件表达式>
2. 关系数据库管理系统提供了定义和检验用户定义完整性的机制，不必由应用程序承担 
   - 插入元组或修改列的值时，关系数据库管理系统检查约束条件是否被满足
   - 如果不满足则操作被拒绝执行

## 5.4 完整性约束命名字

1. 完整性约束命名子句：`CONSTRAINT <完整性约束条件名> <完整性约束条件>`。<完整性约束条件>包括NOT NULL、UNIQUE、PRIMARY KEY短语、FOREIGN KEY短语、CHECK短语

2. 修改表中的完整性限制：使用 ALTER TABLE 语句来修改表中的完整性约束的定义

## 5.5 域中的完整性限制



## 5.6 断言

1. SQL中，可以使用 CREATE ASSERTION 语句，通过声明性断言来指定更具一般性的约束。可以定义涉及多个表的或聚集操作的比较复杂的完整性约束。

2. 断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行。

3. 如果断言很复杂，则系统在检测和维护断言的开销较高，这是在使用断言时应该注意的

创建断言的语句格式：`CREATE ASSERTION <断言名> <CHECK 子句>;`
每个断言都被赋予一个名字，<CHECK 子句>中的约束条件与WHERE子句的条件表达式类似。

删除断言的语句格式：`DROP ASSERTION <断言名>`

## 5.7 触发器

触发器（Trigger）是用户定义在关系表上的一类由事件驱动的特殊过程
触发器保存在数据库服务器中
任何用户对表的增、删、改操作均由服务器自动激活相应的触发器
触发器可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力

### 5.7.1 定义触发器

1. CREATE TRIGGER 语法格式：

   ```
   CREATE TRIGGER <触发器名>
   { BEFORE | AFTER } <触发事件> ON <表名>
   REFERENCING NEW | OLD ROW AS <变量>
   FOR EACH { ROW | STATEMENT }
   [ WHEN <触发条件>] <触发动作体>
   ```

2. 触发器又叫做‘事件-条件-动作’（event-condition-action）规则。
   - 当特定的系统事件‘<触发事件> ON <表名>’发生时，对规则的<触发条件>进行检查，如果<触发条件>成立则执行规则中的动作‘<触发动作体>’，否则不执行该动作
   - 规则中的<触发动作体>可以很复杂，通常是一段SQL存储过程

3. 语法说明：

   - 表的拥有者才可以在表上创建触发器
   - 触发器名：
     - 触发器名可以包含模式名，也可以不包含模式名
     - 同一模式下，触发器名必须是唯一的
     - 触发器名和表名必须在同一模式下

   - 表名：
     - 触发器只能定义在基本表上，不能定义在视图上
     - 当基本表的数据发生变化时，将激活定义在该表上相应触发事件的触发器
   - 触发事件：
     - 触发事件可以是INSERT、DELETE或UPDATE，也可以是这几个事件的组合
     - 触发事件也可以是UPDATE OF <列名>[, <列名>]...，即进一步指明修改哪些列时激活触发器
     - **AFTER/BEFORE是触发的时机**
       - AFTER表示在触发事件的操作执行之后激活触发器
       - BEFORE表示在触发事件的操作执行之前激活触发器

   - 触发器类型
     - 行级触发器（FOR EACH ROW）
     - 语句级触发器（FOR EACH STATEMENT）
   - 触发条件
     - 触发器被激活时，只有当<触发条件>为真时才执行<触发动作体>；否则<触发动作体>不执行。
     - 如果省略 ‘WHEN <触发条件>’，则<触发动作体>在触发器激活后立即执行。
   - 触发动作体
     - 触发动作体可以是一个匿名PL/SQL过程块,也可以是对已创建存储过程的调用
     - 如果是行级触发器，用户可以在过程体中使用NEW和OLD引用事件之后的新值和事件之前的旧值
     - 如果是语句级触发器，则不能在触发动作体中使用NEW或OLD进行引用
     - 如果触发动作体执行失败，激活触发器的事件就会终止执行，触发器的目标表或触发器可能影响的其他对象不发生任何变化

### 5.7.2 激活触发器

1. 触发器的执行，是由触发事件激活的，并由数据库服务器自动执行
2. 一个数据表上可能定义了多个触发器，遵循如下的执行顺序：
   - 执行该表上的BEFORE触发器
   - 激活触发器的SQL语句
   - 执行该表上的AFTER触发器

### 5.7.3 删除触发器

1. 语法：`DROP TRIGGER <触发器名> ON <表名>`

2. 触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除。
