[TOC]

# 第九章 软件体系结构基础

## 9.1 软件体系结构的发展

软件体系结构的必要性：

- 小规模编程：模块内部的程序结构非常依赖程序设计语言提供的编程机制
- 大规模编程：将众多模块组织起来实现需求，需求特别关注模块之间的关系，不依赖于程序设计语言的另外一项技术

## 9.2 理解软件体系结构

### 9.2.1 定义

软件体系结构 = {部件(Component)，连接件(Connector)，配置(Configuration)}

- “部件”是软件体系结构的基本组成单位之一，承载系统的主要功能，包括处理与数据

- “连接件”是软件体系结构的另一个基本组成单位，定义了部件间的交互，是连接的抽象表示
- “配置”是对“形式”的发展，定义了“部件”以及“连接件”之间的关联方式，将它们组织成系统的总体结构

一个软件系统的体系结构规定了系统的计算部件和部件之间的交互

### 9.2.2 区分物理与逻辑

1. 高层 vs 低层
2. 抽象 vs 实践
3. 逻辑是更加高层的视角

**模块**

1. 逻辑：一个模块调用另一个模块
2. 物理实现
   1. 基本：接口调用
   2. 需要传递数据对象怎么办？
3. 逻辑：一个模块给另一个模块传递数据流
4. 物理实现：读写共享数据、pipe…

**物理实现的载体**

1. 低层：基本类型+基本控制结构
2. 中层：OO编程语言机制
   1. 类声明、实例创建与撤销、实例⽣命期管理
   2. 类权限控制机制
   3. 复杂机制：继承…
3. 高层：导⼊导出和名称匹配

**导入导出机制**

**抽象 vs 实现**

1. 建筑设计
2. 函数式组织
3. 体系结构设计
4. 软件实施机制

### 9.2.3 高层抽象（体系结构 = 部件 + 连接件 + 配置）

1. **部件**是计算和状态的聚合
2. **连接件**是组件之间的关系的聚合

- 软件体系结构设计：部件、连接件、配置
- 软件详细设计：过程、调用；类；协作；模块、导入 / 到处
- 软件底层设计：类型、语句；数据结构、算法

**理解高层抽象**：

- 连接件是一个与部件平等的单位
- 部件与连接件是比类、模块等软件单位更高层次的

1. **部件**

   - 可以分为**原始**（Primitive）和**复合**（Composite）两种类型
   - 原始类型的部件可以直接被实现为相应的软件实现机制

   - 复合部件则由**更细粒度**的**部件和连接件**组成，复合部件通过局部配置将其内部的部件和连接件连接起来，构成一个整体

2. **连接件**

   - 也可以分为**原始**（Primitive）和**复合**（Composite）两种类型

   - 原始类型的连接件可以直接被实现为相应的软件实现机制
   - 复合连接件则由更细粒度的**部件和连接件**组成，复合连接件通过局部配置将其内部的部件和连接件连接起来，构成⼀个整体

3. **配置**
   - 一种将部件和连接件整合起来，构成系统整体结构，达到系统的整体结构的机制
4. 高层抽象的好处：
   - 直观、便于理解
   - 验证正确性
   - 关注度分离，降低复杂度



## 9.3 体系结构风格初步

### 9.3.1 主程序 / 子程序

<img src="./9软件体系结构基础/image-20240609212926945.png" alt="image-20240609212926945" style="zoom:67%；" />

主程序：系统的控制器，负责调度各子程序的执行
子程序：局部的控制器，负责调度其子子程序的执行

1. 设计决策与约束
   - 基于声明-使用(程序调用)关系建立连接件，以层次分解的方式建立系统部件，共同组成层次结构。
   - 每⼀个上层部件可以“使用”下层部件，但下层部件不能“使用”上层部件，即不允许逆方向调用。(层次性分解，基于定义使用关系)
   - 系统应该是**单线程**执行。主程序部件拥有初的执行控制权，并在“使用”中将控制权转移给下层子程序。
   - 子程序只能够通过上层转移来获得控制权，可以在执行中将控制权转交给下层的子程序，并在自身执行完成之后必须将控制权还交给上层部件。

2. 实现
   - 主要实现机制：模块实现。
   - 功能分解
   - 集中控制
   - 每个构件⼀个模块实现：主要是**单向依赖**
   - 使用utility或tools等基础模块

3. 效果：
   - 优点：
     - 流程清晰，易于理解（符合分解和分治的思想）
     - 强控制性（容易保证正确性）
   - 缺点：
     - 程序调用是一种强耦合的连接方式，非常依赖交互方的接口规格，这会使得系统难 以修改和复用
     - 程序调用的连接方式限制了各部件之间的数据交互，可能会使得不同部件使用隐含的共享数据交流，产生不必要的公共耦合，进而破坏它的“正确性”控制能力。

4. 应用

### 9.3.2 面向对象式

<img src="./9软件体系结构基础/image-20240609213822290.png" alt="image-20240609213822290" style="zoom:67%；" />

1. 设计决策与约束
   - 依照对数据的使用情况，用信息内聚的标准，为系统建立对象部件。每个对象部件基于内部数据提供对外服务接口，并隐藏内部数据的表示
   - 基于方法调用（Method Invocation）机制建立连接件，将对象部件连接起来
   - 每个对象负责维护其自身数据的一致性与完整性，并以此为基础对外提供“正确”的服务
   - 每个对象都是一个自治单位，不同对象之间是平级的，没有主次、从属、层次、分解等关系
2. 实现
   - 主要实现机制：模块实现
   - 任务分解
   - （委托式）分散式控制
   - 每个构件一个模块实现
     - 使用接口将双向依赖转换为单向依赖
     - 将每个构件分割为多个模块，以保证单向依赖
     - 每个模块内部可以是基于面向对象方法，也可以基于结构化 
   - 使用utility或tools等基础模块
3. 效果
   - 优点：
     - 内部实现的可修改性
     - 易开发、易理解、易复用的结构组织
   - 缺点：
     - 接口的耦合性
     - 标识（Identity）的耦合性
     - 副作用
4. 应用

### 9.3.3 分层

1. 设计决策与约束
   - 从最底层到最高层，部件的抽象层次逐渐提升。每个下层为邻接上层提供服务，每个上层将邻接下层作为基础设施使用。也就是说，在程序调用机制中上层调用下层。
   - 两个层次之间的连接要遵守特定的交互协议，该交互协议应该是成熟、稳定和标准化的。也就是说，只要遵守交互协议，不同部件实例之间是可以互相替换
   - 两个层次之间的连接要遵守特定的交互协议，该交互协议应该是成熟、稳定和标准化的。也就是说，只要遵守交互协议，不同部件实例之间是可以互相替换的
   - 跨层次的连接是禁止的，不允许第 I 层直接调用 I+N（N>1）层的服务
   - 逆向的连接是禁止的，不允许第 I 层调用第 J（J<I）层的服务

2. 实现
   - 关注点分离（每层逐次抽象）
   2. 层间接口使用固定协议（固定控制）
   3. 每层一或多个模块实现
      1. 单向依赖
      2. 层间数据传递建立专门模块
   4. 使用utility或tools等基础模块
3. 效果
   - 优点：
     - 设计机制清晰，易于理解
     - 支持并行开发
     - 更好的可复用性与内部可修改性
   - 缺点：
     - 交互协议难以修改
     - 性能损失
     - 难以确定层次数量和粒度

4. 应用

### 9.3.4 MVC（模型-视图-控制）

1. 设计决策和约束

   - 模型、视图、控制是分别是关于业务逻辑、表现和控制的三种不同内容抽象
   - 如果视图需要持续地显示某个数据的状态，那么它首先需要在模型中注册对该数据的兴趣。如果该数据状态发生了变更，模型会主动通知视图，然后再由视图查询数据的更新情况
   - 视图只能使用模型的数据查询服务，只有控制部件可以调用可能修
     改模型状态的程序
   - 用户行为虽然由视图发起，但是必须转交给控制部件处理。对接收到的用户行为， 控制部件可能会执行两种处理中的一种或两种：调用模型的服务，执行业务逻辑；提供下一个业务展现
   - 模型部件相对独立，既不依赖于视图，也不依赖于控制。虽然模型与视图之间存在一个“通知变更”的连接，但该连接的交互协议是非常稳定的，可以认为是非常弱的依赖

2. 实现

   - 需要为模型、视图和控制的每个部件实例建立模块实现，各模块间存在导入 / 导出关系，程序调用连接件不需要显式的实现

3. 效果

   - 优点：
     - 易开发性
     - 视图和控制的可修改性
     - 适宜于网络系统开发的特征

   - 缺点
     - 复杂性
     - 模型修改困难

4. 应用



## 9.4 项目实践
