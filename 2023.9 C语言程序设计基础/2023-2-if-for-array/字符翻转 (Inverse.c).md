# 字符翻转 (Inverse.c) 

## 题目描述 

给定一个长度为 n 的字符序列，以及翻转的中间节点编号 k，你需要用程序实现输出对这个序列两边各自翻转之后的结果。 

### 输入格式 

第一行输入一个整数 n，其中 $0< n \leq 10^7$ 

第二行输入一个长度为 n 的字符序列，可能包含数字，字母，**空白符**(不含换行符)与特殊符号，从0开始编号

第三行输入一个整数 k，表示翻转的中间节点编号，其中 $0 \leq k \leq n$ ### 输出格式 输出分别对序列 $[0,k−1]$ 位子串（闭区间，如果存在的话）和 $[k,n−1]$ 位子串（闭区间，如果存在的话）翻转之后的结果。 见样例，结果需拼接为一个字符串。

 ### 测试样例 

##### Input

------

```
13
mymymymyqtddt
8
```

##### Output

------

```
ymymymymtddtq
```

##### Input

------

```
11
nswd wsnd s
11
```

##### Output

------

```
s dnsw dwsn
```

##### Input

------

```
9
xw1tw4frs
3
```

##### Output

------

```
1wxsrf4wt
```

### 题目注解 

第一行末尾的换行符该怎么处理呢？慎用`scanf("\n");`！

------

附加任务：

由于卡内存上限会将题目解法引导到奇怪的方向，而且服务器性能有限，所以这里仅留作思考：

如果数据范围上升至**1e8**，内存上限降低至**128MB**，并且要求返回一个翻转后的数组，如何计算数组占用内存？如何编码使得代码能够通过而不**MLE**(Memory Limit Exceed)？

什么叫返回一个翻转后的数组？举个反例： 

```c 
//交换a和b的值?
int main(){
    int a, b;
    scanf("%d%d", &a, &b);
    printf("%d %d", b, a);
    return 0;
}
```

上面的代码并没有交换a和b的值，而只是交换了a和b的输出顺序 返回一个翻转后的数组即是要求对数组进行操作，得到一个真正被翻转后的**数组**，而不是被交换后的输出顺序



# 题解

## 思路

题目要求对一个字符串进行两次翻转操作，分别翻转前半部分和后半部分，然后将两部分拼接起来。可以使用字符串操作来实现这个过程。

## 解题方法

1. 读取输入的整数 `n` 表示字符串的长度。
2. 分配一个字符数组 `str`，大小为 `(n + 1)`，以便能够存储字符串及其结尾的空字符 `'\0'`。
3. 读取输入的字符串，使用 `fgets` 函数来确保正确读取包括空格在内的整行输入。
4. 读取整数 `k`，表示中间节点的位置。需要确保 `k` 在有效范围内，即 $0 \leq k \leq n$。可以使用条件语句来实现。

现在，我们将对字符串进行两次翻转操作以满足题目要求：

1. **翻转前半部分 `[0, k-1]`**：
   - 使用一个循环从字符串的开头开始，移动指针 `start`，并从字符串的末尾开始，移动指针 `end`。
   - 在循环中，交换 `start` 和 `end` 指针位置上的字符，然后将 `start` 向后移动，将 `end` 向前移动，直到 `start` 不再小于 `end`。这将使前半部分 `[0, k-1]` 翻转。
2. **翻转后半部分 `[k, n-1]`**：
   - 使用一个循环从字符串的位置 `k` 开始，移动指针 `start`，并从字符串的末尾开始，移动指针 `end`。
   - 在循环中，交换 `start` 和 `end` 指针位置上的字符，然后将 `start` 向后移动，将 `end` 向前移动，直到 `start` 不再小于 `end`。这将使后半部分 `[k, n-1]` 翻转。
3. **拼接翻转后的两部分**：
   - 可以使用 `printf` 函数将翻转后的字符串输出到标准输出。
4. **释放动态分配的内存**：
   - 最后，别忘了使用 `free` 函数释放动态分配的内存以避免内存泄漏。

## 复杂度

- 时间复杂度：$O(n)$，需要遍历字符串两次进行翻转操作，时间复杂度为线性。
- 空间复杂度：$O(n)$，需要额外的字符串空间来存储输入的字符串。

### Code

```c

```

