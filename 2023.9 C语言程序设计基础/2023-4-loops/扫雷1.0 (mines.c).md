# 扫雷1.0 (mines.c)

## 题目描述

经典游戏扫雷中，给出一张 n×n 的地图，每个格子上给出了周围 8 个格子 (边角为 5 或 3 个) 存在的地雷数量，玩家需要根据这个信息猜测出某个格子上是否有地雷。

现在给出一张 n×n 的地图，上面标示了某处是否有地雷，请你为没有地雷的位置填上相应的数字。

### 输入格式

第一行为一个 n (n≤100)，表示地图大小为 n×n；

接下来 n 行表示地图，用 'o' 表示没有地雷，'*' 表示有地雷。

### 输出格式

n 的地图，图中 '*' 表示地雷，其余位置标记上周围的地雷数目 (0 ~ 8)。

### 测试样例

##### Input

------

```
4
o*oo
*ooo
ooo*
oo*o
```

##### Output

------

```
2*10
*221
122*
01*2
```

### 题目注解

如果你觉得**统计周围地雷数量**实现起来比较复杂，可以观察下面一段演示代码，该代码在 `count` 变量中统计了 `(i, j)` 位置上下左右 `'?'` 的数量

```plain
int vectors[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

int count = 0;
for (int k = 0; k < 4; ++k) {
    int newI = i + vectors[k][0];
    int newJ = j + vectors[k][1];
    if (arr[newI][newJ] == '?') {
        count++;
    }
}
```

你可以通过修改 `vectors` 变量和 `if` 语句的条件来完成统计周围所有地雷数量的任务。（注意边界！）

## 思路

这个问题要求在给定的地雷地图上，为没有地雷的位置标上周围的地雷数量。我们可以按照以下步骤来解决这个问题：

1. **初始化地图：**
      - 首先，我们读取一个整数 \(n\)，它表示地图的大小。
      - 然后，我们读取 \(n\) 行字符，其中 `o` 表示没有地雷的格子，`*` 表示有地雷的格子。


2. **定义方向向量：**
      - 为了查找一个特定格子周围的地雷，我们定义了一个方向向量数组。这个数组包括了一个格子周围8个可能位置的坐标偏移。
        - 方向向量如下：`{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}`。


3. **遍历地图上的每个格子：**
      - 我们使用两层循环遍历地图上的每个格子。
        - 对于每个格子，我们检查它是否有地雷。如果没有，我们进一步检查它周围的格子。


4. **计算周围的地雷数量：**

      - 对于每个没有地雷的格子，我们使用方向向量来检查其周围的格子。

      - 如果周围的格子在地图范围内并且有地雷，我们就增加计数。

      - 计算完成后，我们将计数值存储在当前格子中。


5. **输出结果：**

      - 在完成地图上所有格子的遍历和计数后，我们再次遍历地图并将结果输出到屏幕上。

      - 这时，地图上的每个没有地雷的格子都应该标有周围的地雷数量。


6. **代码优化：**
      - 在代码中，我们通过在地雷计数后直接将计数值转换为字符并存储在地图中，避免了后续的类型转换。
