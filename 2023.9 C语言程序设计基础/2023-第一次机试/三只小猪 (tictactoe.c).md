# 三只小猪 (tictactoe.c)

## 题目描述

三只小猪在下 x 子棋，分别用数字1、2、4表示三只小猪的棋子，用数字0表示该位置上还没有棋子。

规则很简单，在 n×n 的棋盘上，如果在横、竖、对角线三个方向上，有连续 x 个同种棋子连成一线，则这种棋子的“主猪”就获胜了。

但是笨笨小猪们数不清数字，所以需要你来告诉他们谁获胜了，同样也有可能有小猪多下了几回合，

（意味着 1、2、4 在棋盘上的个数之间并没有关联，也不需要在意这个关联）。

正因如此，他们的棋盘上可能出现多只猪都获胜或者没有猪获胜的情况，对于这种情况，你只需要输出`draw`表示平局，否则输出获胜的棋子编号即可。

### 输入格式
第一行有两个整数 t 和 x，分别表示输入的棋盘个数和获胜需要的连续棋子个数，即题面中的x。

接下来有 t 组测试数据，每组测试数据的第一行是一个整数 n，表示棋盘大小。接下来有 n 行，每行有 n 个整数，用空格隔开。

我们对数据做出以下保证：

对于 100% 的数据，保证 $t≤10$；
有 50% 的数据，保证 $x=3，n=3$，最多只有一只猪获胜；
有 20% 的数据，保证 $x=4，n=4$，最多只有一只猪获胜；
对于剩余 30% 的数据，保证 $1≤x≤n≤10$，可能有多只猪都获胜。

### 输出格式
输出共 t 行，每行为获胜的棋子编号（1、2、4）或者`draw`。

### 测试样例1

##### Input

------

```
2 3
3
0 1 0
2 1 4
2 1 2
3
2 0 4
1 2 4
0 1 2
```

##### Output

------

```
1
2
```

### 测试样例2

##### Input

------

```
3 3
4
4 0 1 2
4 4 2 1
1 2 1 1
0 0 1 2
5
1 2 0 0 1
2 1 0 0 2
4 4 4 0 1
1 0 2 0 1
0 2 1 1 0
4
2 1 1 1
0 2 4 0
0 4 2 0
4 0 0 0
```

##### Output

------

```
2
4
draw
```



## Code

```c
#include <stdio.h>
#include <string.h>

int check_winner(int board[10][10], int n, int x, int num) {
    int i, j, k, count;

    // 检查每一行
    for (i = 0; i < n; ++i) {
        for (j = 0; j <= n - x; ++j) {
            count = 0;
            for (k = j; k < j + x; ++k) {
                if (board[i][k] == num) {
                    count++;
                }
            }
            if (count == x) {
                return 1;
            }
        }
    }

    // 检查每一列
    for (i = 0; i < n; ++i) {
        for (j = 0; j <= n - x; ++j) {
            count = 0;
            for (k = j; k < j + x; ++k) {
                if (board[k][i] == num) {
                    count++;
                }
            }
            if (count == x) {
                return 1;
            }
        }
    }

    // 检查对角线
    for (i = 0; i <= n - x; ++i) {
        for (j = 0; j <= n - x; ++j) {
            count = 0;
            for (k = 0; k < x; ++k) {
                if (board[i + k][j + k] == num) {
                    count++;
                }
            }
            if (count == x) {
                return 1;
            }
        }
    }

    // 检查反对角线
    for (i = 0; i <= n - x; ++i) {
        for (j = 0; j <= n - x; ++j) {
            count = 0;
            for (k = 0; k < x; ++k) {
                if (board[i + k][j + x - k - 1] == num) {
                    count++;
                }
            }
            if (count == x) {
                return 1;
            }
        }
    }

    // 没有找到获胜者
    return 0;
}

int main() {
    int t, x, n, i, j, k, winner;
    int board[10][10];

    scanf("%d %d", &t, &x);

    while (t--) {
        scanf("%d", &n);
        memset(board, 0, sizeof(board));

        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
                scanf("%d", &board[i][j]);
            }
        }

        int winners[3] = {0}; // 存储三只小猪是否获胜的情况
        winners[0] = check_winner(board, n, x, 1);
        winners[1] = check_winner(board, n, x, 2);
        winners[2] = check_winner(board, n, x, 4);

        // 检查获胜情况
        winner = 0;
        for (i = 0; i < 3; i++) {
            if (winners[i]) {
                if (winner != 0) {
                    winner = -1; // 表示有多于一只小猪获胜
                    break;
                }
                winner = i == 0 ? 1 : i == 1 ? 2 : 4;
            }
        }

        if (winner == -1) {
            printf("draw\n");
        } else if (winner == 0) {
            printf("draw\n");
        } else {
            printf("%d\n", winner);
        }
    }

    return 0;
}
```

这道题目是一个典型的二维数组遍历问题，结合了游戏规则的具体实现。我们需要在一个二维的棋盘数组中，查找是否存在某个玩家（这里是小猪）的棋子连成了一条线，且这条线的长度等于题目给定的连胜长度x。

具体的实现步骤如下：

1. **初始化和读取输入**:
   - 定义变量和数组来存储棋盘数据以及游戏规则。
   - 读取游戏局数`t`和连胜需要的棋子个数`x`。
   - 对于每一局游戏，读取棋盘大小`n`以及棋盘上每个位置的棋子状态。

2. **定义检查函数**:
   - 实现一个函数`check_winner`，这个函数的作用是检查指定的数字（代表特定小猪的棋子）是否在棋盘上形成了连续`x`个的线（横、竖或对角线）。

3. **遍历棋盘以查找获胜者**:
   - 对于每一局游戏的棋盘，使用`check_winner`函数检查每一只小猪是否获胜。
   - 检查每一行、每一列、两个方向的对角线是否有连续的`x`个相同的棋子。

4. **判断获胜情况**:
   - 对于每一局游戏，通过调用`check_winner`函数的结果来确定是否有获胜者。
   - 如果一个获胜者都没有，则输出`draw`。
   - 如果有一个获胜者，输出那只小猪的编号。
   - 如果有多个获胜者，也输出`draw`表示平局。

5. **输出结果**:
   - 根据上一步的判断，输出每局游戏的结果。

在实现时，还需要注意以下几点：

- 二维数组的索引是从0开始的，所以循环遍历时要注意边界条件。
- 检查对角线时需要额外注意，因为对角线的遍历不像行和列那样直观。
- 检查每个可能的连续`x`个棋子时，需要连续的棋子都是同一个数字，即同一个小猪的棋子。
- 由于可能存在多个获胜者的情况，需要记录所有检查过程中的获胜者，最后再综合判断输出结果。

理解了上述的思路后，实现起来就是顺序地完成每一步的具体代码。上面提供的代码段正是按照这个思路实现的。