# 冒泡排序 (bubble-sort.c)

## 题目描述

某年某月某一天，小 z 在 CPL 课堂上学习了冒泡排序。

下面是老师展示的代码片段，它可以将大小为 n  的数组 $a[0…n-1]$ （即从 $a[0]$ 到 $a[n−1]$）升序排序。

```c
for (int i = 0; i < n; i++) {
  for (int j = 0; j < n - i - 1; j++) {
    if (a[j] > a[j + 1]) {
      int tmp = a[j];
      a[j] = a[j + 1];
      a[j + 1] = tmp;
    }
  }
}
```

在好奇心的驱使下，初学者小 z 将条件 `j < n - i - 1` 改成了 `j < n - i - 2`：

```c
for (int i = 0; i < n; i++) {
  for (int j = 0; j < n - i - 2; j++) { // not j < n - i - 1
    if (a[j] > a[j + 1]) {
      int tmp = a[j];
      a[j] = a[j + 1];
      a[j + 1] = tmp;
    }
  }
}
```

小 z 发现，这段代码对**某些输入**可以正常工作。

小 z 想要知道，给出 n 和数组 $a[0…n-1]$，这份**错误的代码**能否将 a 正确地升序排序？

### 输入格式

输入的第一行包含一个整数  T

接下来有 2T 行，，每两行为一组数据。

对于每一组输入数据，

- 第一行为一个整数 n
- 第二行包含 n 个整数，分别为 $a_0,a_1,…,a_{n-1}$

### 输出格式

输出一共包含 T 行

对于每一组输入数据，输出一行一个字符串 `Yes` 或 `No` ，分别表示小 z 的错误代码 `能/不能` 将输入的数组升序排序。

### 测试样例

##### Input

------

```
2
4
1 2 3 4
5
5 4 3 2 1
```

##### Output

------

```
Yes
No
```

### 题目注解

数据范围与约定

对于 70% 的数据，保证 $1 \leq T \leq 20,1 \leq n \leq 2000$

对于 100% 的数据，保证 $1 \leq T \leq 10^5,1 \leq n \leq 5×10^4, \sum n \leq 10^6 ,|a_i| \leq 10^9$

- 即，对于每个单独的输入文件，每组数据的 n 的总和有上限。

- **注意：**在本题的内存限制下，你无法使用 $T×n$ 大小的数组。

#### 提示

- **70分攻略：** 可以将这段错误的代码抄到你的代码中，对于每一组输入数据，运行这段代码，检查数组是否被升序排序
- **100分攻略：**分析能被正确排序的数组的性质，使用一重循环检查该性质
  - 提示：考虑错误代码中被遗漏的元素需要满足什么条件





## 题解

### 思路

题目要求判断给定的数组是否可以被错误的冒泡排序代码正确排序。我们可以通过以下性质来判断：

- 错误的冒泡排序代码可以正确排序数组的前提是，数组中的最大元素不在内层循环减少的范围内，即最大元素位于数组的最后。

基于这个性质，我们可以通过遍历数组来找到最大元素，并检查它是否在数组的最后一个位置。

### 解题方法

1. 读取输入的测试用例数量 `T`。
2. 对于每个测试用例：
   - 读取数组长度 `n`。
   - 初始化一个变量 `max` 为一个较小的值，以便比较。
   - 初始化一个变量 `last` 用于记录数组的最后一个元素。
   - 遍历数组，同时找到最大的元素并检查是否是最后一个元素。
   - 如果最大元素等于最后一个元素，输出 "Yes"，否则输出 "No"。
3. 继续处理下一个测试用例，直到完成所有测试用例。

### 复杂度

- 时间复杂度：$O(T \cdot n)$，其中 $T$ 是测试用例数量，$n$ 是数组的长度。

- 空间复杂度：$O(n)$

### Code

```c

```

