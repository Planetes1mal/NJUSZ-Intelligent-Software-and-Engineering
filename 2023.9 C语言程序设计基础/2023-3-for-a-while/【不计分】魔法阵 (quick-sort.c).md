# 【不计分】魔法阵 (quick-sort.c)

## 题目背景

可参考[快速排序 - OI Wiki](https://oi-wiki.org/basic/quick-sort/)

抽象地说，快速排序就是一种快速但不太稳定的排序算法，由若干趟重复但区间不同的操作组成；

形象地说，快速排序的过程就像有两个质检员从流水线的两头向中间出发，他们的目的是让产品按照质量从小到大的顺序从左向右排列好，假设小左是从左边出发的质检员，小右是从右边出发的质检员。他们的做法是：选中一个*中间产品*， 并记住这个产品的质量，然后他们开始依次检视产品的质量，如果小左发现当前的产品质量大于等于 *中间产品* 的质量，就停下来，如果小右发现当前产品的质量小于 *中间产品* 的质量，他也停下来（为什么有一人可以取等，另外一人不可以取等？）。如果他们两个都停了下来，就交换这两个产品的位置；如果他们两个碰面了，那么这一趟工作就结束。（他们执行这一趟工作想要做到什么？所以到这里工作的目标一定达成了吗？）

接下来，两位质检员只需要对于 *中间产品* 左半边流水线和右半边流水线分别再进行同样的操作，流水线就会分为四个部分；再对这四个部分执行同样的操作，流水线就会分为八个部分……最后，整个流水线上的产品就会排好序（为什么？）

## 题目描述

在本题中你需要用程序**严格实现**下面的算法：

假设待排序的数组为 $a_0, a_1,…, a_{n-1}$ ，本趟排序开始前，首先需要选定一个“中间值” $pivot$ ，期望在本趟排序完成之后将所有 $< pivot$ 的数放到数组的左侧，而所有 $≥pivot$ 的数放到数组的右侧。为了方便，通常取 $pivot = a_{k-1}$ ，即从数组中取一个数。在本题中，**保证 $pivot $ 在数组中仅出现一次 ，这个算法实现的是：算法执行完成后 $pivot $ 右侧的数均 $>pivot $，而其左侧的数均 $< pivot $ 。

排序过程中，首先使用两个变量 l 和 r，l 按 0,1,2,…,n−1 的顺序从左向右遍历数组下标，初始为 0 ，而 r 按 n−1, n−2, n−3,…, 0 的顺序从右向左遍历下标，初始为 n−1。排序过程如下：

1. l 从当前位置向右遍历，直到 l==r 或遇到一个 $\geq pivot$ 的数。
2. r 从当前位置向左遍历，直到 l*==*r 或遇到一个 $<pivot$* 的数。
3. 如果 l 和 r 不相等 ，则交换 $a_l$ 和 $a_r$ 的值。
4. 如果 l 和 r 不相等，继续从步骤 1 开始往下执行，直到  l 与 r  相等为止。

在 l 和 r 相遇以后，当前的数组 a 仍可能不满足本题中的要求。为满足要求，还需对 a 中的两个元素进行至多一次交换，不妨来看看样例2，在某次循环中，当 l 已经找到一个大于等于 pivot 的数，但 r 并未找到一个小于 pivot 的数就已经与 l 相等了的时侯，在 pivot 的左边仍然有一个大于等于它的数，这时就需要将 l 这个位置上的数与 pivot 对应位置的数相交换。

请注意：为实现本题的目的有多种正确的实现，**如果你不严格按照上述给出的方法编写代码，将很可能拿不到本题的分数。**

你可能还想问：如何才能找到 pivot 现在在哪个位置呢？

同样有多种做法，不过用不同的实现不会影响你的得分（只要你的实现确实是正确的），这里给出最简单的做法：

既然 pivot 的值在数组中仅出现一次，在算法开始之前记录下它的值，然后在循环结束后再遍历一遍数组，看看和它相等的数在哪个位置就可以了

### 输入格式

第一行为两个整数 n 和 k，以空格隔开，分别表示序列的长度和被选为中间值的数在序列是第几个数，即 $pivot = a_{k-1}$（序列从0开始编号），保证 1≤n≤1000000，1≤*k*≤*n*，第 k 个数在序列中只出现一次。

第二行，n 个整数，以空格隔开，表示待排序的数列，保证在 `int` 范围内。

### 输出格式

共一行 n 个整数，以空格隔开，表示经过题目描述的算法排序后的序列。

### 测试样例

##### Input

------

```
7 5
1 9 1 9 8 1 0
```

##### Output

------

```
1 0 1 1 8 9 9
```

##### Input

------

```
5 3
1 6 5 7 8
```

##### Output

------

```
1 5 6 7 8
```

### 题目注解

本题的算法原型是快速排序的分区交换算法。

做完了题目，你可能仍有疑惑：快速排序为什么是正确的？在这里我们给出一个形象的理解方式（不是证明）：在一趟排序之后，我们保证了存在某个下标 p ，使得 $a[0:p]$ 和 $a[p+1:n−1]$ 两个区间中任何两个数有序，如果我们进行很多趟，每趟都选取合适的区间 ，直到数组中的每一个 $a[i:i]$ 和 $a[i+1:i+1]$ 都有序，那么排序就完成了。



## 题解

### 思路

这道题目要求我们实现快速排序的分区交换算法，即使用两个指针（l 和 r）分别从数组的两端向中间移动，以将小于 pivot 的数放在 pivot 的左侧，大于等于 pivot 的数放在 pivot 的右侧。在每一趟排序之后，保证存在一个下标 p，使得数组的左侧部分 [0:p] 和右侧部分 [p+1:n-1] 中的任何两个数都是有序的。

### 解题方法

1. 从输入中获取数组的长度 n 和中间值的位置 k。
2. 读取待排序的数组 a，并将 k 减一以得到正确的索引。
3. 选取中间值 pivot，即 a[k-1]。
4. 初始化两个指针 l 和 r，分别为 0 和 n-1，用于从数组的两端向中间移动。
5. 进入主循环，其中 l 从左向右遍历，直到找到一个大于等于 pivot 的数，或者 l 和 r 相遇。然后 r 从右向左遍历，直到找到一个小于 pivot 的数，或者 l 和 r 相遇。
6. 如果 l 和 r 不相等，交换 a[l] 和 a[r] 的值，以确保小于 pivot 的数移到左侧，大于等于 pivot 的数移到右侧。
7. 继续从步骤 5 开始执行，直到 l 和 r 相遇。
8. 主循环结束后，数组 a 的左侧部分应该包含小于 pivot 的数，右侧部分应该包含大于等于 pivot 的数。但数组仍然不满足题目的要求，因此需要将 pivot 移动到正确的位置。交换 pivot 和 a[l] 的值，以确保 pivot 右侧的数都大于等于 pivot，左侧的数都小于 pivot。
9. 最后，输出排序后的数组 a。

### 复杂度

- 时间复杂度：$O(n)$ - 主要的工作是在一趟排序中完成的，每次都将数组分成两部分。

- 空间复杂度：$O(n)$ - 由于需要存储输入数组 a。

### Code

```c

```

