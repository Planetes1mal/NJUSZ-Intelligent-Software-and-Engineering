# JoJo 谜题 (josephus.c)

## 题目描述

现在有个游戏：39 个玩家与 Jack 及他的朋友躲到一个洞中，39个玩家决定了一个出局方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须出局，然后再由下一个重新报数，直到所有人都出局为止。然而 Jack 和他的朋友并不想遵从。首先从一个人开始，越过 *k-2* 个人（因为第一个人已经被越过），并淘汰掉第 *k* 个人。接着，再越过 *k-1* 个人，并淘汰掉第 *k* 个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以成为最后的赢家。问题是，给定了和，一开始要站在什么地方才能避免被淘汰。 Jack 要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是成为了最后赢家。

现在我们模拟这个游戏，给定 n 个人的编号为 1, 2, ..., n，从编号为 1 的人开始，每报数报到 k 则该人出局，再从下一个人开始重新开始报数。

问：最后一个没有出局的人的编号是多少？

### 输入格式

输入一行两个正整数 n，k（$1 \leq n，k \leq 500$）

### 输出格式

输出一个数为最后一人的编号

### 测试样例

##### Input

------

```
41 3
```

##### Output

------

```
31
```

##### Input

------

```
6 5
```

##### Output

------

```
1
```

### 题目注解

样例解释：

样例1中，出局的顺序是：3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 1, 5, 10, 14, 19, 23, 28, 32, 37, 41, 7, 13, 20, 26, 34, 40, 8, 17, 29, 38, 11, 25, 2, 22, 4, 35, 16

样例2中，出局的顺序是：5, 4, 6, 2, 3

------

提示：

我们提供三种思路，从易到难：

1. 可以用一个数组存放 0, 1 表示存活的状态，用循环去模拟报数的过程。
2. 可以用 next[1] = 2, next[2] = 3, ..., next[n] = 1 来表示他们围成一圈的样子。同样用循环模拟这一过程。
3. 可以思考这个问题：我们设答案为一个函数 f(n, k)。当我们进行完第一轮之后，问题事实上变成了 f(n - 1, k) （只是编号发生了相对位移）。你可以考虑潜在的递推公式。

## 题解

### 思路

这个问题是经典的约瑟夫问题（Josephus Problem），可以使用递归来解决。基本思路是：首先处理特殊情况，当只有一个人时，该人为最后的赢家；对于有多个人的情况，可以通过递归调用自身来找到问题的解。

### 解题方法

1. 如果只有一个人，那么这个人就是最后的赢家，返回1。
2. 否则，递归调用`josephus`函数，输入n-1和k，这样可以找到n-1个人的游戏中的赢家。
3. 使用递推公式 `(josephus(n - 1, k) + k - 1) % n + 1` 来计算n个人的游戏中的赢家，其中 `(josephus(n - 1, k) + k - 1)` 表示在n-1个人的游戏中淘汰第k个人后的赢家编号，然后再加1，因为编号是从1开始的。

### 复杂度

- 时间复杂度：$O(n)$，由于递归调用的次数与 n 成正比。

- 空间复杂度：$O(n)$，递归调用会使用栈空间。

### Code

```c

```

