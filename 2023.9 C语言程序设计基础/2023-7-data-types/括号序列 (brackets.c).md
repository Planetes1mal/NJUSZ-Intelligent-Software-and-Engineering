# 括号序列 (brackets.c)

## 题目描述

定义一个合法括号序列（balanced bracket sequence）为仅由`()[]{}`构成的字符串且:

- 空串是一个合法括号序列。
- 如果串s是合法括号序列，那么(s)，[s]和{s}也都是合法括号序列。（(s)表示在s两边加上()得到的字符串，如s = [()]，那么(s) = ([()])）
- 如果s, t都是合法括号序列，那么st也是合法括号序列。(st表示s和t相连得到的字符串)

给出 T 个字符串，判断每个字符串是否是一个合法的括号序列。

### 输入格式
第一行一个整数 T（T⩽30），表示一共有 T 组数据。

之后 T 行每行输入一个字符串 s（$∣s∣⩽10^5$），为给定的括号序列。

### 输出格式

一共 T 行，每行一个True或者False，表示对应的字符串 s 是/不是合法的括号序列。

### 测试样例

##### Input

------

```
4
[(])
([)]
([{}])([])
())(()
```

##### Output

------

```
False
False
True
False
```



这道题目的核心在于判断一个由括号组成的字符串是否是合法的括号序列。合法的括号序列遵循两个主要规则：

1. **每个开括号都必须有一个相应的闭括号与之匹配**。例如，每个 '(' 需要一个 ')', 每个 '[' 需要一个 ']', 每个 '{' 需要一个 '}'。
2. **括号的匹配必须按照正确的顺序**。例如，字符串 "([)]" 是不合法的，尽管它包含相等数量的开括号和闭括号，但它们的顺序不正确。

为了检查这些条件，我们可以使用一个栈来跟踪未匹配的开括号。栈是一种理想的数据结构，因为它提供了后进先出（LIFO）的特性，这正是我们处理嵌套括号时所需要的。

### 实现思路

1. **初始化栈**：创建一个空栈来存储遇到的开括号。
2. **遍历字符串**：逐个检查字符串中的字符。
   - 如果是开括号（`([{`），则将其压入栈中。这表示我们期待在未来找到一个匹配的闭括号。
   - 如果是闭括号（`)]}`），则需要检查栈顶元素：
     - 如果栈为空，这意味着没有相应的开括号与当前的闭括号匹配，因此字符串不是合法的括号序列。
     - 如果栈不为空，则检查栈顶元素是否与当前闭括号匹配：
     - 如果匹配，则从栈中弹出栈顶元素，继续处理字符串的下一个字符。
     - 如果不匹配，则字符串不是合法的括号序列。
3. **检查栈状态**：在遍历完字符串后，如果栈为空，则所有开括号都找到了匹配的闭括号，字符串是合法的括号序列。如果栈不为空，意味着有一些开括号没有找到匹配的闭括号，因此字符串不是合法的括号序列。

### 关键点

- **栈的使用**：栈是解决这类问题的关键，因为它可以帮助我们跟踪最近未匹配的开括号。
- **匹配规则**：正确地匹配开括号和闭括号是判断字符串是否合法的关键。
- **边界条件处理**：确保在处理闭括号时栈不为空，以及在最后检查栈是否为空，以确认所有括号都已正确匹配。

通过这种方法，我们可以有效地判断任何给定的括号序列是否合法。