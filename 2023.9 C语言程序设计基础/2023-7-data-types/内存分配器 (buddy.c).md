# 内存分配器 (buddy.c)

## 题目描述

Buddy Memory Allocation 是一种内存管理算法。在本题中，我们需要实现这个算法的简化版本。

假设计算机在分配内存时总是分配大小为 $2^k$;(k∈N) 的内存空间。例如，若某应用程序需要大小为 5 的内存空间，计算机则会分配大小为 $8=2^3$ 的一块内存。

为了便于管理，Buddy 将整个内存空间视作一个“空间链”，由多个“空间节点”连接组成，每个“空间节点”负责管理一个大小固定为 $2^i(\text{for some }i∈N)$ 的内存空间块。

每次分配内存时，会先寻找大小合适的“空间节点”。如果找不到，则会触发“空间分裂”操作。`

下面给出 Buddy 算法分配内存过程的较为形式化的描述，供参考：

- 初始时，计算机内存为一块，大小给定，此时的“空间链”仅包含一个“空间节点”。
- 分配内存时，假设需要的内存块大小为 $2^k$：

1. 寻找现有的大小恰好为 $2^k$ 的“空间节点”中是否有还未被分配的。
2. 若有，分配最靠前的那个。
3. 若没有，则寻找大小 $2^k$ 的、最靠前的、未被分配的“空间节点”，将其分裂成大小分别为原来一半、位置相邻的两个新“空间节点”，按次序连接之后替换原“空间链”中被分裂的节点；重复过程 1。

在此题中，你需要支持两种操作：

- `A id m` 表示一个识别码为 id 的程序请求大小为 m 的内存空间。
- `Q` 表示查询系统中当前空间的分配情况。

### 输入格式

- 第一行输入两个正整数 $n(n<31)$ 和 $q(q≤10000)$，以空格隔开，分别表示计算机的内存大小为 $2^n$ 以及操作的总数。
- 接下来有 q 行，每行一个操作，格式如上所述。

#### 限制与约定

- 对于 30% 的数据，保证计算机每次分配的内存空间都相同。

- 对于 100% 的数据，保证 n<31,q≤10000，保证每次操作合法，即：内存空间足够，应用程序的 id 互不相同，id不为 0。

### 输出格式

对于每一个 Q 询问，输出两行：

- 第一行为一个整数 m ，表示当前“空间链结点”的总数。
- 第二行依次输出 m 个整数，按照起始地址从小到大输出每一个“空间结点”上的应用程序的 id ，若某节点空闲，则输出 0 。

### 测试样例

##### Input

------

```
4 7
Q
A 1 1
Q
A 2 1
Q
A 3 2
Q
```

##### Output

------

```
1
0
5
1 0 0 0 0
5
1 2 0 0 0
5
1 2 3 0 0
```

##### Input

------

```
8 10
A 114 4
A 810 14
Q
A 514 1
A 1919 8
A 7777 7
Q
A 555 9
A 66 2
Q
```

##### Output

------

```
7
114 0 0 810 0 0 0
11
114 514 0 0 1919 810 7777 0 0 0 0
11
114 514 0 66 1919 810 7777 0 555 0 0
```



要实现这个 Buddy Memory Allocation 算法，我们首先需要理解其工作原理，然后根据这些原理来设计和实现相应的数据结构和函数。下面是实现这个算法的详细思路：

### 1. 理解 Buddy Memory Allocation 算法

Buddy Memory Allocation 算法是一种内存管理技术，它通过将内存分割成大小为 \(2^k\) 的块来简化内存分配和释放。这种方法的关键在于，当请求一个大小为 \(m\) 的内存块时，实际分配的内存大小是 \(2^k\)，其中 \(k\) 是满足 \(2^k \geq m\) 的最小整数。

### 2. 设计数据结构

为了实现这个算法，我们需要一个数据结构来表示内存中的每个块（节点）。每个节点需要包含以下信息：

- `id`：标识占用该内存块的程序（如果有的话）。
- `size`：内存块的大小。
- `next`：指向链表中下一个节点的指针。

### 3. 初始化内存系统

初始化时，我们创建一个大小为 \(2^n\) 的内存块，这是整个内存系统的起始点。这个块最初是未分配的，因此其 `id` 应该设置为 0。

### 4. 内存分配

内存分配的过程涉及以下步骤：

- **计算所需大小**：根据请求的大小 \(m\)，计算出所需的实际内存块大小 \(2^k\)。
- **查找合适的块**：遍历内存链表，寻找第一个足够大且未被分配的内存块。
- **分裂块**：如果找到的块大于所需大小，就将其分裂成两个更小的块，直到块的大小等于所需大小。
- **分配内存**：将找到的或分裂出的合适大小的块标记为已分配，并记录程序的 `id`。

### 5. 查询内存状态

查询内存状态时，我们需要遍历整个内存链表，统计节点的数量，并输出每个节点的状态（包括它的 `id` 和是否被分配）。

### 6. 实现

根据以上思路，我们可以实现相应的函数：

- `initializeBuddySystem`：初始化内存系统。
- `allocateMemory`：实现内存分配逻辑。
- `splitNode`：当找到的内存块大于所需时，分裂该块。
- `queryMemory`：遍历内存链表，输出当前内存的分配情况。

### 7. 注意事项

- 这个实现是简化的，没有考虑内存释放和合并空闲块的情况。
- 在实际应用中，内存管理通常还包括错误处理和优化，例如避免内存泄漏和碎片化。

通过遵循这些步骤，我们可以构建一个基本的 Buddy Memory Allocation 系统，它能够处理内存分配请求并查询当前的内存状态。